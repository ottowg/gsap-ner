{"text": "Calibrated Prediction Intervals for Neural Network Regressors\n\nAbstract:\nOngoing developments in neural network models are continually advancing the state of the art in terms of system accuracy. However, the predicted labels should not be regarded as the only core output; also important is a well-calibrated estimate of the prediction uncertainty. Such estimates and their calibration are critical in many practical applications. Despite their obvious aforementioned advantage in relation to accuracy, contemporary neural networks can, generally, be regarded as poorly calibrated and as such do not produce reliable output probability estimates. Further, while post-processing calibration solutions can be found in the relevant literature, these tend to be for systems performing classification. In this regard, we herein present two novel methods for acquiring calibrated predictions intervals for neural network regressors: empirical calibration and temperature scaling. In experiments using different regression tasks from the audio and computer vision domains, we find that both our proposed methods are indeed capable of producing calibrated prediction intervals for neural network regressors with any desired confidence level, a finding that is consistent across all datasets and neural network architectures we experimented with. In addition, we derive an additional practical recommendation for producing more accurate calibrated prediction intervals. We release the source code implementing our proposed methods for computing calibrated predicted intervals. The code for computing calibrated predicted intervals is publicly available 1 .\n\nMain:\n\n\n\n1. Introduction\nDeep learning has undoubtedly improved the state-of-the-art performance of machine learning models across a variety of machine learning applications, in terms of overall system accuracy []. In addition, there is an increasing research attention within the deep learning community on estimating prediction uncertainty, i. e., recognising and quantifying when an output may be incorrect. The estimation of uncertainty can indeed be crucial for a wide range of applications. For example, the decisions made by neural network technology deployed in healthcare settings could have life-threatening consequences. Uncertainty information could therefore act as a guide for clinicians or doctors to seek a potentially life saving advice.\nFor a regression problem, uncertainty of a model output can be estimated using prediction intervals -estimates of the interval in which the target label is expected to lie within a prescribed probability. Standard neural network regressors output a point estimation [1, 2, 3], from which the estimation of calibrated prediction intervals is a non-trivial task. Other neural network regressors use a technique which poses the regression task as a classification task, with a softmax output that produces a posterior distribution over the output space [4, 5]. Using this method, one could compute prediction intervals for a given confidence level \u03b1, simply by taking an interval in the output space that contains \u03b1 of the posterior probability mass, as illustrated in Figure 1.\nHowever, an interval in the output space that contains \u03b1 of the posterior probability mass does not have to correspond to a probability of \u03b1 that the label will fall within this interval's boundaries. For example, a neural network making overconfident predictions may tend to concentrate \u03b1 of the posterior probability mass in small intervals of the output space, while the probability that these intervals contain the actual labels can be considerably lower. In this case, we say that the prediction intervals are miscalibrated. Recent work has shown that the outputs of modern neural network classifiers are miscalibrated in the sense that posterior class probabilities do not reflect actual correctness probabilities [6]. Therefore, when using neural network regressors that are designed as such classifiers, we expect the resulting prediction intervals to be miscalibrated as well.\nNeural network models have not always been considered miscalibrated. Indeed, work presented in [6, 7] identified premodern neural network models as a good learning paradigm in terms of producing well-calibrated probabilities for binary classification tasks. It has been demonstrated that the poor calibration levels observed in more contemporary deep topologies have come about through recent changes in network architecture and training procedures [6]. For example, miscalibration has been associated with increases in model capacity, and has also been observed in networks trained with batch normalisation or a minimal amount of weight decay [6].\nDespite network calibration being a more recent problem for neural nets, calibration and confidence estimation themselves are not new problems, e. g., [8, 9, 10, 11, 12, 13, 14, 15]. More recently, a plethora of calibration and uncertainty quantification approaches have been proposed and developed for contemporary neural networks in the wider machine learning community. Bayesian Neural Networks produce a probabilistic relationship between the network input and output [16, 17], but often suffer from tractability issues. Ensemble based approaches, bootstrapping, and Monte Carlo based approaches have also been proposed, for example [18, 19, 20, 21]. While such approaches can produce calibrated prediction intervals, they often require training and testing a multitude of different individual networks which considerably increases the associated time and computational costs [22]. Closely related to the current work, a range of post-processing calibration tasks of neural network classifiers were evaluated for a range of different networks topologies [6]. The authors found some of the evaluated methods to successfully calibrate the outputs of the classification models, but counterpart methods for producing calibrated prediction intervals for neural network regressors are still absent. Motivated by the above, in this work we present two novel methods for producing calibrated prediction intervals for neural network regressors, at any desired confidence level. Both of our proposed methods are performed as post-processing of the outputs of a the trained regression model that uses a softmax classification layer, therefore do not require retraining of the model, and are very fast to compute. Our first proposed method, empirical calibration, assesses the amount of the model's posterior probability mass that corresponds in practice to the desired confidence level. Our second proposed method, temperature scaling, is an adaptation of a related method proposed in [6] for calibrating classification models, to the regression and prediction intervals setting. Temperature scaling tunes the smoothness of the model's output distribution, to find a balance that results in calibrated prediction intervals.\nWe corroborate our proposed methods in experiments with four regression tasks from the audio and computer vision domains. We first find that as expected, using neural network classifiers to perform regression, and obtaining prediction intervals by taking an interval in the output space that contains the desired posterior probability mass, results in prediction intervals that are poorly calibrated. On the contrary, we find that applying our proposed calibration methods yields prediction intervals that are considerably better calibrated, a finding that is consistent across all datasets, neural network architectures and confidence levels we experimented with.\nFurther, we find that when splitting the output space into a finite number of bins, using a larger number of bins and applying our proposed methods results in calibrated prediction intervals that are tighter, i.e., a more accurate estimation of the range in which the label may fall. Finally, we validate that using neural network classifiers to perform regression does not cause any degradation in regression performance, as measured by mean squared error. We conclude that both of are proposed methods are appropriate for emitting calibrated prediction intervals for neural network regressors. We make the source code using empirical calibration and temperature scaling for computing calibrated predicted intervals publicly available 2.\nThe rest of this paper is laid out as follows. In Section 2 we present how regression can be performed using neural network classifiers, and how (not calibrated) prediction intervals can be obtained; Section 2.2 then presents the two proposed calibration methods. The experimental results on the different tasks are presented in Section 3, and finally a brief conclusion and our future work plans are given in Section 4.\n\n2. Acquiring Prediction Intervals\n\n\n2.1. Posterior Prediction Intervals\nWe consider neural network regressors that process an input x \u2208 R n with an associated label y \u2208 R. For a regression task, the standard neural network contains a top layer with only one unit [1, 2, 3]. The single value in the output of this top layer is then used together with the ground-truth label to compute the mean squared error, which is the training objective of the network. Using this standard design, the network only outputs a single point estimate, and there is no obvious way to use the network's output for computing prediction intervals.\nIn contrast, a natural approach for designing neural networks regressors from which prediction intervals can be derived, is to construct a regressor that emits a probability distribu-Posterior Probability M bins Neural Network Figure 1 : A neural network regressor designed as a softmax classifier. By binning the output space into M bins, one can design a neural network regressor as a softmax classifier over M classes, and derive a posterior distribution over the output space instead of a single point estimate. This allows emitting prediction intervals that contain a prescribed amount of the posterior probability mass. However, we show that the resulting prediction intervals will normally be miscalibrated, i. e., will not correspond to the desired confidence level.\ntion px over the real numbers, and use this distribution to define intervals with a certain level of probability mass. Denoting \u0176x as a real-valued random variable that is distributed according to px, we define the notion of posterior prediction intervals:Definition 1 The interval (ux, vx) is called posterior \u03b1- prediction interval if P[u(x) < \u0176x < v(x)] = \u03b1 and u(x) < E[ \u0176x] < v(x).\nThe posterior prediction interval (ux, vx) is simply an interval around the expected prediction of the network E[ \u0176x] that is designed to contain a probability mass of \u03b1 from the network's output distribution px. We refer to \u03b1 as the confidence level of the interval.\nWith the aim of emitting a probability distribution over the real numbers, neural network regressors can be designed similarly to conventional neural network classifiers, as was done in [4, 5]. The real numbers are divided into a finite number of bins M with edges\u2212\u221e = a0 < a1 < ... < aM = \u221e,\nand for the training procedure each real-valued label y is replaced with the appropriate class label t \u2208 {0, ..., M \u2212 1} such that at \u2264 y < at+1.\nThe single unit top layer of the standard neural network regressors is replaced with a layer of M \u2212 1 units. Softmax normalisation is then applied on the output of the top layer and the network is trained as a standard neural network classifier with the cross-entropy loss. The output of such a neural network is a vector of class probabilities (pr0, ..., prM\u22121).\nTo emit a probability distribution over the real numbers, we can distribute each class probability uniformly, or according to the distribution of training set real-valued labels, between the class's bin boundaries.\nPosing the regression problem as a classification problem allows the network to emit a distribution over the real numbers instead of a point estimate, which in turn can be used to calculate posterior \u03b1-prediction intervals.\n\n2.2. Calibrated Prediction Intervals\nIn Section 2.1 we described how neural network regressors can be designed in a manner that allows emitting posterior \u03b1prediction intervals. However, the confidence level \u03b1 does not guarantee that the label is likely to fall within its appropriate posterior prediction interval with probability \u03b1. For example, consider the case of a neural network that produces overly confident predictions. In this case, the output probability distribution px will have most of its mass concentrated in a small region, therefore prediction intervals containing a mass of \u03b1 of the network's output probability distribution will be very narrow. However, despite the confident predictions, the actual groundtruth labels might fall within the boundaries of those intervals on average only \u03b10 of the times, with \u03b10 < \u03b1. Equivalently, the confidence level \u03b1 may also not represent the actual probability of the label falling within the prediction interval's boundaries in the case of network predictions that are not confident enough.\nIdeally, one would aspire to obtain prediction intervals with a confidence level of \u03b1, such that \u03b1 is the actual probability of the label falling within the prediction interval's boundaries. We define the notion of calibrated prediction intervals:Definition 2 A set of intervals {(ux, vx)}x\u2208X is considered as calibrated \u03b1-prediction intervals if Px,y\u223cX,Y [ux < y < vx] = \u03b1,\nwhere X, Y corresponds to the joint distribution of inputs and labels of the given regression task.\nWe refer to \u03b1 as the confidence level of the calibrated prediction intervals. In regression analysis, a calibrated prediction interval is an estimate of an interval in which the label will lie, with a certain probability \u03b1. Calibrated prediction intervals capture information about the uncertainty of the predicted value across the output space, and convey information that is absent from a single point estimate of the label, that might be critical for a wide range of practical applications.\nIn recent work, it was shown that modern neural network classifiers tend to produce non-calibrated outputs, i. e., the posterior probability assigned to predictions does not correspond to the actual ground-truth accuracy of these predictions [6]. Therefore, when using neural network regressors that are constructed as classifiers, and using those to emit posterior \u03b1-prediction intervals, we cannot expect those posterior \u03b1-prediction intervals to be calibrated \u03b1-prediction intervals. In Section 3 we show that indeed in practice, the obtained posterior \u03b1-prediction intervals are not calibrated \u03b1-prediction intervals.\nBelow we present the main novel contribution of this work, two methods for computing calibrated \u03b1-prediction intervals for neural network regressors. Consider the neural network regressors designed as classifiers described in Section 2.1. Recall that in this setting we divide the real numbers into M bins, and given an input x, a regressor emits a categorical probability distribution over the different bins: (pr0, ..., prM\u22121).\nWe compute the network's real-valued prediction (point estimate) as the expected prediction with respect to the emitted class probability distribution:\u0177 = M \u22121 i=0 pri * ci,\nwhere ci is the mean of real-valued labels of all training examples with class label i. We denote the class that contains \u0177 (according to its bin's edges) with t: t = r s.t. ar \u2264 \u0177 \u2264 ar+1.\n()\nFor computing posterior \u03b1-prediction intervals, we take the smallest symmetric interval around t that contains \u03b1 of the neural network's posterior probability mass. Formally, we take the posterior \u03b1-prediction interval to be(u \u03b1 x , v \u03b1 x ) = (a t\u2212i , a t+1+i ),\nsuch that i is the minimal non-negative integer (possibly zero) for whichpr t\u2212i + ... + pr t+i \u2265 \u03b1.\nNote that we restrict the endpoints of the interval to be the discrete bins edges, therefore the condition from Definition 1 only holds approximately.\nIn the rest of this section we describe our two proposed novel methods for calibrating the prediction intervals. Both methods apply post-processing to the outputs of a trained neural network, and do not require retraining the neural network. The hyperparameters of the methods are to be chosen using a validation set, and the chosen values should then be used when applying the methods to the test set predictions.\n\n2.2.1. Empirical Calibration\nWe first observe that posterior \u03b10-prediction intervals (u \u03b1 0\nx , v \u03b1 0 x ) as defined according to (3) are actually calibrated \u03b11-prediction intervals for\u03b11 = Px,y\u223cX,Y [u \u03b1 0 x < y < v \u03b1 0 x ].\nThis holds because for every set of prediction intervals, there is an actual probability of the label falling within the boundaries of those intervals. Therefore by definition those are calibrated prediction intervals with this probability as their confidence level. When calibrating the prediction intervals empirically, we want to find \u03b10 such that the posterior \u03b10-prediction intervals are calibrated \u03b1-prediction intervals, for a desired confidence level \u03b1. Note that Px,y\u223cX,Y [u \u03b1 0\nx < y < v \u03b1 0 x ] is increasing in \u03b10 with fixed points in 0 and 1, since larger posterior prediction intervals necessarily mean that the label is more likely to fall within the intervals' boundaries.\nTherefore, our empirical calibration method is comprised of a binary search along different values of \u03b10\u2208 [0, 1] to find \u03b10 such that |Px,y\u223cX,Y [u \u03b1 0 x < y < v \u03b1 0\nx ] \u2212 \u03b1| < on the validation set, for a given error tolerance . In our experiments we use = 0.001. The error tolerance is necessary, since for a finite validation set finding calibrated prediction intervals with confidence level exactly \u03b1 may be impossible. The \u03b10 that we end up with is the one that is used for computing prediction intervals on for the test set.\n\n2.2.2. Temperature Scaling\nWhen training the neural network for the classification task, class probabilities (pr0, ..., prM\u22121) are computed from the output of the top layer (z0, ..., zM\u22121) using the softmax function:pri = exp(zi/T ) M \u22121 j=0 exp(zj/T ) , ()\nwhere T is called the softmax temperature. During training, the default temperature T = 1 is used. Equation 6 can be written aspri = 1 M \u22121 j=0 exp((zj \u2212 zi)/T ) ,\nthat shows that the output of the softmax normalisation depends only on the the temperature T and the differences between the output values (z0, ..., zM\u22121). Therefore, scaling the outputs of the top layer before applying the softmax function affects the smoothness of the output probability distribution. Specifically, using a lower temperature 0 < T < 1 makes the probability distribution \"pointier\", i. e., more probability mass is given to the classes with higher z values. On the contrary, using a larger temperature 1 < T < \u221e tends towards distributing the probability mass more evenly between the different classes.\nUsing this property of the softmax normalisation function, temperature scaling uses a different temperature at evaluation time for computing class probabilities. A network that produces overconfident predictions, will result in posterior \u03b1-prediction intervals that are too narrow, i. e., Px,y\u223cX,Y [u \u03b1\nx < y < v \u03b1 x ] < \u03b1. In this case, temperature scaling with a temperature T > 1 can be applied to reduce the network's confidence, and increase the width of the posterior prediction intervals. Equivalently, a low temperature 0 < T < 1 should be used to increase the network's confidence and decrease the width of posterior prediction intervals.\nMore generally, we defineF\u03b1(T ) = Px,y\u223cX,Y [u \u03b1 x < y < v \u03b1 x ]\nwhere u \u03b1 x and v \u03b1 x are the posterior \u03b1-prediction intervals that now depend also on T . As increase in T increases the width of the posterior prediction intervals, the function F\u03b1(T ) is continuous and monotonic increasing in T , with limT \u21920 F\u03b1(T ) = 0 and limT \u2192\u221e F\u03b1(T ) = 1. Therefore, there must be a temperature T such that F\u03b1(T ) = \u03b1.\nMotivated by the above theoretical properties, our temperature scaling method is comprised of a binary search along different values of T to find the temperature value such that|F\u03b1(T ) \u2212 \u03b1| <\non the validation set, for the desired confidence level \u03b1 and a given error tolerance of . In our experiments we use an error tolerance = 0.001 that is again necessary, since for a finite validation set finding calibrated prediction intervals with confidence level exactly \u03b1 may be impossible. The temperature T that is chosen using the validation set is then used for computing prediction intervals for the test set. Temperature scaling was used in [6] for calibrating the output probabilities of neural network classifiers, and here we extend this method to the regression and prediction intervals setting.\n\n3. Experiments\nWe evaluated our two proposed calibration methods for prediction intervals on four different regression tasks from the audio and computer vision domains.\n\n3.1. Datasets and Tasks\nWe describe the four regression tasks and datasets we used in our experiments.\n\n3.1.1. Age Prediction (Audio)\nThe first task we consider is the prediction speakers' age based on a recording of their speech, using the aGender corpus [23, 24]. The aGender corpus contains audio recordings of predefined utterances and natural speech, annotated for the speakers' age and gender. We split the corpus into speaker independent training, validation and test sets, according to the split used in [25]. In total, the three sets contain more than 38 hours of audio, in more than 53,000 utterances. The total number of speakers is 611, such that 331 speakers are assigned to the training set, 140 to the validation set, and 299 to the test set. We extracted Mel-Frequency Cepstrum Coefficients (MFCC) features from each recordings, using frames of 25 ms shifted by 10 ms.\nFrom every frame 13 features were extracted. We applied mean and standard deviation normalisation across features and time, for every recording separately.\n\n3.1.2. SNR Prediction\nThe second regression task from the audio domain we experimented with is prediction of Signal-to-Noise Ratio (SNR) of speech audio utterances with background noise. For constructing this task's corpus, we used clean speech utterances from the degree of nativeness corpus from the INTERSPEECH 2016 computational paralinguistics challenge [26, 27] and background noise recordings from the CHiME-4 challenge [28]. The native language corpus contains more than 64 hours of clean speech utterances from 5,132 speakers of 11 different native languages, split into speaker independent training, validation, and test sets. The background noises are recordings of four different environments: bus, caf\u00e9, pedestrian area, street junction, and are 14 hours in total. For creating the training set, training speech utterances were mixed with random segments of the background noises according to a random SNR in the range [0, 25]. The SNR was then used as the real-valued label for the regression task. The validation and test set were created in a similar manner, using the corresponding clean utterances from the native language corpus and dedicated portions of the noise recordings. We applied a short-time Fourier transform (STFT) on every recording to extract 201 magnitude spectrogram features from every 25 ms frame, where frames are shifted 10 ms. The magnitude spectrogram features were then normalised across features and time, for every utterance separately, to have a mean of 0 and a standard deviation of 1.\n\n3.1.3. Age Prediction (Images)\nThe first dataset we experimented with in the computer vision domain is the Wikipedia faces dataset [29]. The dataset contains 62,359 images of people (one image per person) crawled from Wikipedia, labelled with the age of each person at the time the picture was taken. Since the dataset has no official training/validation/test split, we randomly allocated 60% of the examples to the training set, 20% to the validation set and 20%\nto the test set. As the dimensions of the different images vary, we resized every image to 224 \u00d7 224 pixels before feeding it to the neural network. In addition, we normalised pixel values for every image separately, to have a mean of 0 and a standard deviation of 1.\n\n3.1.4. ISO Speed Prediction\nThe second images dataset we experimented with is the MIRFLICKR-25000 dataset. The MIRFLICKR-25000 dataset consists of 25,000 images downloaded from the social photography site Flickr through its public API [30]. In addition to images, the dataset contains additional metadata on every image, such as the ISO speed, that measures the sensitivity of the camera's film or sensor to light. The ISO speed affects the brightness of photos, therefore a regression task for predicting the ISO speed of given images is sensible. We split the dataset and extracted features in the same way as described in Section 3.1.3.\n\n3.2. Neural Networks\nAs described in Section 2, we learn the regression tasks using a classification neural network, where the real numbers are split into M bins. For the audio experiments, the network we used is comprised of two long short-term memory (LSTM) layers, each with 512 units. The output of the last time step in the top layer is fed into the fully-connected output layer, with the number of units equal to the number of bins we use. Softmax normalisation is applied to the output layer's units.\nFor the computer vision experiments, we used a convolutional neural net (CNN) that is comprised of 8 residual blocks [2]. Each residual block first applies a convolutional layer on the input, followed by batch normalisation [31] and a rectified linear activation function. A second convolutional layer is then applied on the output of the rectified linear activation, and the output is added to the block's input. Batch normalisation and another rectified linear activation are then applied, to emit the output of the residual block. Before applying the residual blocks, a convolutional layer with a 7 \u00d7 7 kernel is applied on the network's input, with a 2 \u00d7 2 stride and 64 feature maps. The output of this convolutional layer is fed to the a sequence of 8 residual blocks, all using convolutional kernel size of 3 \u00d7 3 and 64,64,128,128,256,256,512,512 feature maps (one value for each residual block). A 2 \u00d7 2 stride is applied for residual blocks number 3, 5 and 7. A global average pooling is applied on the output of the last residual block, to average each of the 512 feature maps across all spatial locations. Similarly to the audio experiments, a fully-connected layer is then applied to project the 512 dimensional vector to the relevant number of bins, and a softmax normalisation is applied.\nIn all experiments, the training objective is the standard cross-entropy, and model parameters are learnt using the Adam optimiser [32] with default \u03b21, \u03b22 values and a learning rate of 0.001. We experimented with binning the real numbers into M = 10, 30, 60 bins to demonstrate that our method can operate successfully regardless of the number of bins, and to study the differences between the resulting prediction intervals with different number of bins. For a given number of classes M , we set class boundaries a0, ..., aM to be equally spaced between the minimum and maximum real-valued label values in the training set, and then set a0 = \u2212\u221e and aM = \u221e. Table 1 : A comparison of test set calibration error ([%]) before ('Posterior' column) and after applying each of the the two proposed calibration methods for the different regression tasks. 'Empirical', 'Temp' and 'Conf' columns represent empirical calibration, temperature scaling and the prediction intervals' confidence level respectively. In all cases, both of the proposed methods manage to considerably reduce the calibration error of prediction intervals, compared to prediction intervals based on the networks' posterior distribution (smaller numbers on the right side of the dashed line). Both of the proposed methods yield comparable performance. This result holds when training the network with either 10, 30 or 60 bins, with no clear advantage for a specific number of bins.\n\nDataset\n\n\n3.3. Calibration Results\nFor the main results of this work, we evaluated each of the two proposed calibration methods from Section 2.2 on the different regression tasks, with different neural network architectures and different number of bins. For each task, we trained three neural networks with 10, 30 and 60 bins. Each of the proposed calibration methods was applied to the outputs of each trained network using confidence levels of 66%, 80% and 90%. For each calibration method and dataset, the associated hyperparameters were chosen using the validation set, then we applied this cali-bration method to the test set using the chosen hyperparameters.\nAll results we report are on the test set. The aim of each calibration method is to produce calibrated \u03b1-prediction intervals. To assess the level in which this goal was achieved, we measure the calibration error, which is the absolute difference between the desired confidence level \u03b1 and the actual probability of the label falling within the boundaries of the acquired prediction intervals. Mathematically, the calibration error is defined as|Px,y\u223cX,Y [u(x) < y < v(x)] \u2212 \u03b1|,\nwhere (u(x), v(x)) is the prediction interval emitted by the calibration method for example x, and X, Y are distributed uniformly over the test set examples.\nA comparison of the calibration error when using the posterior prediction intervals, and after applying each of the two proposed calibration methods is given in Table 1. First, we observe that the posterior prediction intervals, without applying a calibration method, generally yield a large calibration error. This finding is consistent with findings from [6] regarding the miscalibration of modern neural network classifiers. Second, we see that in all cases, both the empirical calibration and temperature scaling methods manage to considerably reduce the calibration error, eliminating the calibration error to small levels of normally around 0%-2%. These results indicate that using these methods, calibrated prediction intervals for neural network regressors can indeed be acquired. Moreover these findings hold across all datasets, confidence levels, and number of bins used for training the networks.\nHowever, even when using one of the two proposed calibration methods, calibration error does not vanish completely. The reason for this is that calibration hyperparameters were chosen on the validation set, and do not generalise perfectly to the test set. Nevertheless, a calibration error of 1%-2% is sufficiently enough for the majority of applications (e.g., a confidence level of 81% instead of a desired 80% will not make a large difference in most applications). Both calibration methods yield comparable performance, and are fast to execute, typically around 1-3 seconds for a test set of 10000 examples, depending on the number of bins used.\nFurther, we compare the width of the emitted prediction intervals for the empirical calibration and temperature scaling methods. Table 2 contains the average width of the prediction intervals for test sets of the different regression tasks. Posterior prediction intervals were above to be poorly calibrated, therefore their width is not meaningful with respect to the desired confidence level, and we omit them from Table 2. We first observe that naturally, the width of the interval grows with the desired confidence level. The main conclusion that can be derived from these results is that networks trained using a larger number of bins tend to produce tighter prediction intervals. Specifically, for all tasks except age prediction from audio signal, the width of the resulting calibrated prediction intervals is generally smaller when using 30 or 60 bins, compared to 10 bins. The reason for this phenomenon is that a larger number of bins allows the network a more precise allocation of posterior probability mass.\nAdditionally, we find that the two calibration methods produce prediction intervals of a comparable width, with no prominent advantage for neither of the two methods. This result indicates that both methods can be interchangeably used to produce calibrated prediction intervals of the same quality. Lastly, we note that width of the prediction intervals is closely affected by Table 2 : A comparison of the test set average width of prediction intervals using the two proposed calibration methods, empirical calibration and temperature scaling. 'Empirical', 'Temperature' and 'Confidence' columns represent empirical calibration, temperature scaling and the prediction intervals' confidence level respectively. For all datasets except 'Age Audio', training the network with more bins generally results in tighter prediction intervals, since the network can learn a more precise distribution of posterior probability (numbers in the 30 and 60 bins rows are generally smaller than in the 10 bins rows). The width of the intervals is comparable between the two calibration methods and naturally grows with the confidence level. Finally, the width of the intervals naturally depends on the performance of the neural network in the regression task. the quality of the regressor that they are based on. A better neural network regressor is one that assigns a higher probability mass around the correct labels, which will in turn result in tighter prediction intervals.\n\n3.4. Regression Results\nFor studying the the effect of performing the regression tasks using neural network classifiers, we additionally train a standard neural network regressor for each of the tasks. For each task the standard neural network regressor is trained with an identical architecture to the corresponding neural network classifier for this task, except the topmost layer that contains only a single unit, as described in Section 2. The regressor is trained with the same optimiser as the classifiers to minimise the mean squared error (MSE) between the network's predictions and the labels. For the classification models, MSE is computed using the prediction \u0177 defined in Eq. 1.\nThe root MSE on the test set for the different models is found in Table 3. The results in the table show that regression performance of the standard regressor and the classifiers is generally comparable on all tasks. We therefore conclude that training neural network regressors using neural network classifiers, that allow emitting calibrated prediction intervals, does not cause any degradation in the regression task performance.\nTable 3 : Performance in the different regression tasks as measured by the root MSE, for a standard neural network regressor and a neural network classifier with different number of classes (denoted as cls'). The performance of the standard regressors is comparable to the performance of the models performing regression using a classification models. This indicates that using neural network classifiers to perform regression task, that allow emitting calibrated prediction intervals, does not cause any degradation in the regression performance.\n\nDataset\n\n\n4. Conclusions\nThe output of contemporary neural networks, despite being highly accurate in many circumstances, can be considered miscalibrated, thereby producing unreliable output probability estimates [6]. This issue is exacerbated in regression, in which the output of a standard neural network regressor is a point estimate of the predicted values. By posing neural network regression as a multi-class classification problem and introducing two novel post-processing calibration methods, we demonstrated that it is possible to produce well-calibrated prediction intervals for neural network regression, that can be critical for a large variety of real-world application. We find that our proposed methods were fast to execute and produce calibration prediction intervals for any desired confidence level, across a variety of regression tasks from the audio and computer vision domains and different neural network architectures. In addition, we found that using a larger number of classification bins generally resulted in tighter prediction intervals, and importantly, that using our proposed methods does not cause any degradation in regression performance, as measured by the mean squared error.\nFuture work includes exploring alternative training mechanisms that will lead to tighter calibrated prediction intervals [33, 34], embedding the calibrated outputs into the decision making process of more complex models such as [35], and applying the proposed methods to a variety of applications such as computational paralinguistics [36, 37, 38]. Further, given the complication when performing regression fusion associated with effects such as multicollinearity, we also plan to test our approach to aid late fusion of multiple neural network regressors.\n\nFootnotes:\n1: Code available in http://github.com/cruvadom/ Prediction_Intervals\n2: code available in http://github.com/cruvadom/ prediction_intervals\n\nReferences:\n\n- A. Toshev and C. Szegedy, \"Deeppose: Human pose estimation via deep neural networks,\" in Proceedings of CVPR, Columbus, OH, 2014, pp. 1653-1660.- K. He, X. Zhang, S. Ren, and J. Sun, \"Deep residual learning for image recognition,\" in Proceedings of CVPR, Las Vegas, NV, 2016, pp. 770-778.\n\n- S. Yao, Y. Zhao, H. Shao, A. Zhang, C. Zhang, S. Li, and T. Ab- delzaher, \"Rdeepsense: Reliable deep mobile computing models with uncertainty estimations,\" Proceedings of ACM Interactive Mobile Wearable Ubiquitous Technology, vol. 1, no. 4, pp. 173:1- 173:26, Jan. 2018.\n\n- A. V. Oord, N. Kalchbrenner, and K. Kavukcuoglu, \"Pixel recur- rent neural networks,\" in Proceedings of ICML, New York, NY, 2016, pp. 1747-1756.\n\n- A. van den Oord, S. Dieleman, H. Zen, K. Simonyan, O. Vinyals, A. Graves, N. Kalchbrenner, A. Senior, and K. Kavukcuoglu, \"Wavenet: A generative model for raw audio,\" in 9th ISCA Speech Synthesis Workshop, Sunnyvale, CA, 2016, pp. 125-125.\n\n- C. Guo, G. Pleiss, Y. Sun, and K. Q. Weinberger, \"On calibration of modern neural networks,\" in Proceedings of ICML, Sydney, Australia, 2017, pp. 1321-1330.\n\n- A. Niculescu-Mizil and R. Caruana, \"Predicting good probabil- ities with supervised learning,\" in Proceedings of ICML, Bonn, Germany, 2005, pp. 625-632.\n\n- A. P. Dawid, \"The well-calibrated bayesian,\" Journal of the Amer- ican Statistical Association, vol. 77, no. 379, pp. 605-610, 1982.\n\n- M. Weintraub, F. Beaufays, Z. Rivlin, Y. Konig, and A. Stolcke, \"Neural-network based measures of confidence for word recogni- tion,\" in Proceedings of the International Conference on Acous- tics, Speech, and Signal Processing (ICASSP), vol. 2, Munich, Germany, 1997, pp. 887-890.\n\n- J. Platt et al., \"Probabilistic outputs for support vector machines and comparisons to regularized likelihood methods,\" Advances in large margin classifiers, vol. 10, no. 3, pp. 61-74, 1999.\n\n- F. Wessel, R. Schluter, K. Macherey, and H. Ney, \"Confidence measures for large vocabulary continuous speech recognition,\" IEEE Transactions on Speech and Audio Processing, vol. 9, no. 3, pp. 288-298, Mar. 2001.\n\n- H. Jiang, \"Confidence measures for speech recognition: A sur- vey,\" Speech Communication, vol. 45, no. 4, pp. 455 -470, 2005.\n\n- N. Brummer and D. A. V. Leeuwen, \"On calibration of language recognition scores,\" in 2006 IEEE Odyssey -The Speaker and Language Recognition Workshop, San Juan, Puerto Rico, 2006, pp. 1-8.\n\n- D. Yu, J. Li, and L. Deng, \"Calibration of confidence measures in speech recognition,\" IEEE Transactions on Audio, Speech, and Language Processing, vol. 19, no. 8, pp. 2461-2473, Nov. 2011.\n\n- J. Deng and B. Schuller, \"Confidence Measures in Speech Emo- tion Recognition Based on Semi-supervised Learning,\" in Pro- ceedings of INTERSPEECH, Portland, OR, 2012, pp. 2226-2229.\n\n- R. M. Neal, Bayesian learning for neural networks. Springer Science & Business Media, 2012, vol. 118.\n\n- A. Kendall and Y. Gal, \"What uncertainties do we need in bayesian deep learning for computer vision?\" in Proceedings of NIPS, Long Beach, CA, 2017, pp. 5574-5584.\n\n- B. Lakshminarayanan, A. Pritzel, and C. Blundell, \"Simple and scalable predictive uncertainty estimation using deep ensembles,\" in Proceedings of NIPS, I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, Eds., Long Beach, CA, 2017, pp. 6402-6413.\n\n- A. Khosravi, S. Nahavandi, D. Srinivasan, and R. Khosravi, \"Con- structing optimal prediction intervals by using neural networks and bootstrap method,\" IEEE Transactions on Neural Networks and Learning Systems, vol. 26, no. 8, pp. 1810-1815, Aug. 2015.\n\n- Y. Gal and Z. Ghahramani, \"Dropout as a bayesian approxima- tion: Representing model uncertainty in deep learning,\" in Pro- ceedings of ICML, New York, NY, 2016, pp. 1050-1059.\n\n- A. Naumov, V. Spokoiny, and V. Ulyanov, \"Bootstrap confidence sets for spectral projectors of sample covariance,\" arXiv preprint arXiv:1703.00871, 2017.\n\n- H. Li, X. Wang, and S. Ding, \"Research and development of neu- ral network ensembles: a survey,\" Artificial Intelligence Review, vol. 49, no. 4, pp. 455-479, Apr. 2018.\n\n- F. Burkhardt, M. Eckert, W. Johannsen, and J. Stegmann, \"A database of age and gender annotated telephone speech,\" in Pro- ceedings of the International Conference on Language Resources and Evaluation (LREC), Valletta, Malta, 2010.\n\n- B. Schuller, S. Steidl, A. Batliner, F. Burkhardt, L. Devillers, C. M\u00fcller, and S. Narayanan, \"The INTERSPEECH 2010 Paralin- guistic Challenge,\" in Proceedings of INTERSPEECH, Makuhari, Japan, 2010, pp. 2794-2797.\n\n- G. Keren and B. Schuller, \"Convolutional RNN: an enhanced model for extracting features from sequential data,\" in Proceed- ings of the International Joint Conference on Neural Networks (IJCNN), Vancouver, Canada, 2016, pp. 3412-3419.\n\n- B. Schuller, S. Steidl, A. Batliner, J. Hirschberg, J. K. Burgoon, A. Baird, A. Elkins, Y. Zhang, E. Coutinho, and K. Evanini, \"The INTERSPEECH 2016 Computational Paralinguistics Challenge: Deception & Sincerity,\" in Proceedings of INTERSPEECH, San Francsico, CA, 2016, pp. 2001-2005.\n\n- G. Keren, J. Deng, J. Pohjalainen, and B. Schuller, \"Convolutional neural networks with data augmentation for classifying speakers' native language,\" in Proceedings of INTERSPEECH, San Franc- sico, CA, 2016, pp. 2393-2397.\n\n- E. Vincent, S. Watanabe, A. A. Nugraha, J. Barker, and R. Marxer, \"An analysis of environment, microphone and data simulation mismatches in robust speech recognition,\" Computer Speech & Language, vol. 46, pp. 535-557, 2017.\n\n- R. Rothe, R. Timofte, and L. V. Gool, \"Dex: Deep expectation of apparent age from a single image,\" in IEEE International Confer- ence on Computer Vision Workshops (ICCVW), Santiago, Chile, 2015.\n\n- B. T. Mark J. Huiskes and M. S. Lew, \"New trends and ideas in visual concept detection: The mir flickr retrieval evaluation initia- tive,\" in Proceedings of the 2010 ACM International Conference on Multimedia Information Retrieval MIR, New York, NY, 2010, pp. 527-536.\n\n- S. Ioffe and C. Szegedy, \"Batch normalization: Accelerating deep network training by reducing internal covariate shift,\" in Proceed- ings of ICML, Lille, France, 2015, pp. 448-456.\n\n- D. Kingma and J. Ba, \"Adam: A method for stochastic optimiza- tion,\" in Proceedings of the International Conference on Learning Representations (ICLR), San Diego, CA, 2015.\n\n- G. Keren, S. Sabato, and B. Schuller, \"Tunable sensitivity to large errors in neural network training,\" in Proceedings of AAAI, San Francisco, CA, 2017, pp. 2087-2093.\n\n- G. Keren, S. Sabato, and B. Schuller, \"Fast single-class classi- fication and the principle of logit separation,\" in Proceedings of ICDM, Singapore, 2018.\n\n- G. Keren, M. Schmitt, T. Kehrenberg, and B. Schuller, \"Weakly supervised one-shot detection with attention siamese networks,\" arXiv preprint arXiv:1801.03329, 2018.\n\n- J. Deng, X. Xu, Z. Zhang, S. Fr\u00fchholz, and B. Schuller, \"Ex- ploitation of Phase-based Features for Whispered Speech Emo- tion Recognition,\" IEEE Access, vol. 4, pp. 4299-4309, Jul. 2016.\n\n- J. Deng, S. Fr\u00fchholz, Z. Zhang, and B. Schuller, \"Recognizing Emotions From Whispered Speech Based on Acoustic Feature Transfer Learning,\" IEEE Access, vol. 5, no. 1, pp. 5235-5246, Dec. 2017.\n\n- E. Marchi, S. Fr\u00fchholz, and B. Schuller, \"The Effect of Narrow- band Transmission on Recognition of Paralinguistic Information from Human Vocalizations,\" IEEE Access, vol. 4, pp. 6059-6072, Oct. 2016.\n\n", "annotations": {"ReferenceToTable": [{"begin": 27366, "end": 27367, "idx": 0}, {"begin": 29618, "end": 29619, "idx": 1}, {"begin": 31145, "end": 31146, "idx": 2}, {"begin": 31432, "end": 31433, "idx": 3}, {"begin": 32413, "end": 32414, "idx": 4}, {"begin": 34257, "end": 34258, "idx": 5}, {"begin": 34624, "end": 34625, "idx": 6}], "ReferenceToFootnote": [{"begin": 8333, "end": 8334, "target": "#foot_1", "idx": 0}], "SectionMain": [{"begin": 1655, "end": 36937, "idx": 0}], "SectionReference": [{"begin": 37091, "end": 44578, "idx": 0}], "SectionHeader": [{"begin": 0, "end": 1655, "idx": 0}], "Div": [{"begin": 73, "end": 1647, "idx": 0}, {"begin": 1658, "end": 8756, "idx": 1}, {"begin": 8758, "end": 8792, "idx": 2}, {"begin": 8794, "end": 12055, "idx": 3}, {"begin": 12057, "end": 16423, "idx": 4}, {"begin": 16425, "end": 17868, "idx": 5}, {"begin": 17870, "end": 20770, "idx": 6}, {"begin": 20772, "end": 20940, "idx": 7}, {"begin": 20942, "end": 21044, "idx": 8}, {"begin": 21046, "end": 21982, "idx": 9}, {"begin": 21984, "end": 23514, "idx": 10}, {"begin": 23516, "end": 24247, "idx": 11}, {"begin": 24249, "end": 24888, "idx": 12}, {"begin": 24890, "end": 28147, "idx": 13}, {"begin": 28149, "end": 28157, "idx": 14}, {"begin": 28159, "end": 33492, "idx": 15}, {"begin": 33494, "end": 35165, "idx": 16}, {"begin": 35167, "end": 35175, "idx": 17}, {"begin": 35177, "end": 36937, "idx": 18}], "Head": [{"begin": 1658, "end": 1673, "n": "1.", "idx": 0}, {"begin": 8758, "end": 8791, "n": "2.", "idx": 1}, {"begin": 8794, "end": 8829, "n": "2.1.", "idx": 2}, {"begin": 12057, "end": 12093, "n": "2.2.", "idx": 3}, {"begin": 16425, "end": 16453, "n": "2.2.1.", "idx": 4}, {"begin": 17870, "end": 17896, "n": "2.2.2.", "idx": 5}, {"begin": 20772, "end": 20786, "n": "3.", "idx": 6}, {"begin": 20942, "end": 20965, "n": "3.1.", "idx": 7}, {"begin": 21046, "end": 21075, "n": "3.1.1.", "idx": 8}, {"begin": 21984, "end": 22005, "n": "3.1.2.", "idx": 9}, {"begin": 23516, "end": 23546, "n": "3.1.3.", "idx": 10}, {"begin": 24249, "end": 24276, "n": "3.1.4.", "idx": 11}, {"begin": 24890, "end": 24910, "n": "3.2.", "idx": 12}, {"begin": 28149, "end": 28156, "idx": 13}, {"begin": 28159, "end": 28183, "n": "3.3.", "idx": 14}, {"begin": 33494, "end": 33517, "n": "3.4.", "idx": 15}, {"begin": 35167, "end": 35174, "idx": 16}, {"begin": 35177, "end": 35191, "n": "4.", "idx": 17}], "Paragraph": [{"begin": 73, "end": 1647, "idx": 0}, {"begin": 1674, "end": 2403, "idx": 1}, {"begin": 2404, "end": 3179, "idx": 2}, {"begin": 3180, "end": 4065, "idx": 3}, {"begin": 4066, "end": 4714, "idx": 4}, {"begin": 4715, "end": 6931, "idx": 5}, {"begin": 6932, "end": 7596, "idx": 6}, {"begin": 7597, "end": 8335, "idx": 7}, {"begin": 8336, "end": 8756, "idx": 8}, {"begin": 8830, "end": 9383, "idx": 9}, {"begin": 9384, "end": 10158, "idx": 10}, {"begin": 10159, "end": 10415, "idx": 11}, {"begin": 10546, "end": 10813, "idx": 12}, {"begin": 10814, "end": 11078, "idx": 13}, {"begin": 11107, "end": 11252, "idx": 14}, {"begin": 11253, "end": 11616, "idx": 15}, {"begin": 11617, "end": 11831, "idx": 16}, {"begin": 11832, "end": 12055, "idx": 17}, {"begin": 12094, "end": 13107, "idx": 18}, {"begin": 13108, "end": 13355, "idx": 19}, {"begin": 13483, "end": 13582, "idx": 20}, {"begin": 13583, "end": 14076, "idx": 21}, {"begin": 14077, "end": 14698, "idx": 22}, {"begin": 14699, "end": 15128, "idx": 23}, {"begin": 15129, "end": 15280, "idx": 24}, {"begin": 15303, "end": 15491, "idx": 25}, {"begin": 15492, "end": 15493, "idx": 26}, {"begin": 15495, "end": 15719, "idx": 27}, {"begin": 15758, "end": 15831, "idx": 28}, {"begin": 15858, "end": 16008, "idx": 29}, {"begin": 16009, "end": 16423, "idx": 30}, {"begin": 16454, "end": 16516, "idx": 31}, {"begin": 16517, "end": 16610, "idx": 32}, {"begin": 16650, "end": 17137, "idx": 33}, {"begin": 17138, "end": 17338, "idx": 34}, {"begin": 17339, "end": 17443, "idx": 35}, {"begin": 17504, "end": 17868, "idx": 36}, {"begin": 17897, "end": 18086, "idx": 37}, {"begin": 18128, "end": 18255, "idx": 38}, {"begin": 18292, "end": 18913, "idx": 39}, {"begin": 18914, "end": 19216, "idx": 40}, {"begin": 19217, "end": 19561, "idx": 41}, {"begin": 19562, "end": 19587, "idx": 42}, {"begin": 19626, "end": 19969, "idx": 43}, {"begin": 19970, "end": 20147, "idx": 44}, {"begin": 20162, "end": 20770, "idx": 45}, {"begin": 20787, "end": 20940, "idx": 46}, {"begin": 20966, "end": 21044, "idx": 47}, {"begin": 21076, "end": 21826, "idx": 48}, {"begin": 21827, "end": 21982, "idx": 49}, {"begin": 22006, "end": 23514, "idx": 50}, {"begin": 23547, "end": 23979, "idx": 51}, {"begin": 23980, "end": 24247, "idx": 52}, {"begin": 24277, "end": 24888, "idx": 53}, {"begin": 24911, "end": 25397, "idx": 54}, {"begin": 25398, "end": 26700, "idx": 55}, {"begin": 26701, "end": 28147, "idx": 56}, {"begin": 28184, "end": 28813, "idx": 57}, {"begin": 28814, "end": 29259, "idx": 58}, {"begin": 29293, "end": 29450, "idx": 59}, {"begin": 29451, "end": 30359, "idx": 60}, {"begin": 30360, "end": 31009, "idx": 61}, {"begin": 31010, "end": 32029, "idx": 62}, {"begin": 32030, "end": 33492, "idx": 63}, {"begin": 33518, "end": 34184, "idx": 64}, {"begin": 34185, "end": 34617, "idx": 65}, {"begin": 34618, "end": 35165, "idx": 66}, {"begin": 35192, "end": 36379, "idx": 67}, {"begin": 36380, "end": 36937, "idx": 68}], "ReferenceToBib": [{"begin": 2670, "end": 2673, "target": "#b0", "idx": 0}, {"begin": 2674, "end": 2676, "target": "#b1", "idx": 1}, {"begin": 2677, "end": 2679, "target": "#b2", "idx": 2}, {"begin": 2954, "end": 2957, "target": "#b3", "idx": 3}, {"begin": 2958, "end": 2960, "target": "#b4", "idx": 4}, {"begin": 3900, "end": 3903, "target": "#b5", "idx": 5}, {"begin": 4161, "end": 4164, "target": "#b5", "idx": 6}, {"begin": 4165, "end": 4167, "target": "#b6", "idx": 7}, {"begin": 4515, "end": 4518, "target": "#b5", "idx": 8}, {"begin": 4710, "end": 4713, "target": "#b5", "idx": 9}, {"begin": 4866, "end": 4869, "target": "#b7", "idx": 10}, {"begin": 4870, "end": 4872, "target": "#b8", "idx": 11}, {"begin": 4873, "end": 4876, "target": "#b9", "idx": 12}, {"begin": 4877, "end": 4880, "target": "#b10", "idx": 13}, {"begin": 4881, "end": 4884, "target": "#b11", "idx": 14}, {"begin": 4885, "end": 4888, "target": "#b12", "idx": 15}, {"begin": 4889, "end": 4892, "target": "#b13", "idx": 16}, {"begin": 4893, "end": 4896, "target": "#b14", "idx": 17}, {"begin": 5187, "end": 5191, "target": "#b15", "idx": 18}, {"begin": 5192, "end": 5195, "target": "#b16", "idx": 19}, {"begin": 5352, "end": 5356, "target": "#b17", "idx": 20}, {"begin": 5357, "end": 5360, "target": "#b18", "idx": 21}, {"begin": 5361, "end": 5364, "target": "#b19", "idx": 22}, {"begin": 5365, "end": 5368, "target": "#b20", "idx": 23}, {"begin": 5595, "end": 5599, "target": "#b21", "idx": 24}, {"begin": 5773, "end": 5776, "target": "#b5", "idx": 25}, {"begin": 6693, "end": 6696, "target": "#b5", "idx": 26}, {"begin": 9021, "end": 9024, "target": "#b0", "idx": 27}, {"begin": 9025, "end": 9027, "target": "#b1", "idx": 28}, {"begin": 9028, "end": 9030, "target": "#b2", "idx": 29}, {"begin": 11000, "end": 11003, "target": "#b3", "idx": 30}, {"begin": 11004, "end": 11006, "target": "#b4", "idx": 31}, {"begin": 14319, "end": 14322, "target": "#b5", "idx": 32}, {"begin": 20612, "end": 20615, "target": "#b5", "idx": 33}, {"begin": 21198, "end": 21202, "target": "#b22", "idx": 34}, {"begin": 21203, "end": 21206, "target": "#b23", "idx": 35}, {"begin": 21454, "end": 21458, "target": "#b24", "idx": 36}, {"begin": 22343, "end": 22347, "target": "#b25", "idx": 37}, {"begin": 22348, "end": 22351, "target": "#b26", "idx": 38}, {"begin": 22411, "end": 22415, "target": "#b27", "idx": 39}, {"begin": 23647, "end": 23651, "target": "#b28", "idx": 40}, {"begin": 24484, "end": 24488, "target": "#b29", "idx": 41}, {"begin": 25515, "end": 25518, "target": "#b1", "idx": 42}, {"begin": 25622, "end": 25626, "target": "#b30", "idx": 43}, {"begin": 26832, "end": 26836, "target": "#b31", "idx": 44}, {"begin": 29808, "end": 29811, "target": "#b5", "idx": 45}, {"begin": 35380, "end": 35383, "target": "#b5", "idx": 46}, {"begin": 36501, "end": 36505, "target": "#b32", "idx": 47}, {"begin": 36506, "end": 36509, "target": "#b33", "idx": 48}, {"begin": 36608, "end": 36612, "target": "#b34", "idx": 49}, {"begin": 36715, "end": 36719, "target": "#b35", "idx": 50}, {"begin": 36720, "end": 36723, "target": "#b36", "idx": 51}, {"begin": 36724, "end": 36727, "target": "#b37", "idx": 52}], "ReferenceString": [{"begin": 37106, "end": 37250, "id": "b0", "idx": 0}, {"begin": 37252, "end": 37394, "id": "b1", "idx": 1}, {"begin": 37398, "end": 37668, "id": "b2", "idx": 2}, {"begin": 37672, "end": 37816, "id": "b3", "idx": 3}, {"begin": 37820, "end": 38059, "id": "b4", "idx": 4}, {"begin": 38063, "end": 38219, "id": "b5", "idx": 5}, {"begin": 38223, "end": 38375, "id": "b6", "idx": 6}, {"begin": 38379, "end": 38511, "id": "b7", "idx": 7}, {"begin": 38515, "end": 38795, "id": "b8", "idx": 8}, {"begin": 38799, "end": 38989, "id": "b9", "idx": 9}, {"begin": 38993, "end": 39204, "id": "b10", "idx": 10}, {"begin": 39208, "end": 39333, "id": "b11", "idx": 11}, {"begin": 39337, "end": 39525, "id": "b12", "idx": 12}, {"begin": 39529, "end": 39718, "id": "b13", "idx": 13}, {"begin": 39722, "end": 39903, "id": "b14", "idx": 14}, {"begin": 39907, "end": 40008, "id": "b15", "idx": 15}, {"begin": 40012, "end": 40174, "id": "b16", "idx": 16}, {"begin": 40178, "end": 40464, "id": "b17", "idx": 17}, {"begin": 40468, "end": 40720, "id": "b18", "idx": 18}, {"begin": 40724, "end": 40900, "id": "b19", "idx": 19}, {"begin": 40904, "end": 41056, "id": "b20", "idx": 20}, {"begin": 41060, "end": 41228, "id": "b21", "idx": 21}, {"begin": 41232, "end": 41463, "id": "b22", "idx": 22}, {"begin": 41467, "end": 41680, "id": "b23", "idx": 23}, {"begin": 41684, "end": 41917, "id": "b24", "idx": 24}, {"begin": 41921, "end": 42205, "id": "b25", "idx": 25}, {"begin": 42209, "end": 42431, "id": "b26", "idx": 26}, {"begin": 42435, "end": 42658, "id": "b27", "idx": 27}, {"begin": 42662, "end": 42856, "id": "b28", "idx": 28}, {"begin": 42860, "end": 43128, "id": "b29", "idx": 29}, {"begin": 43132, "end": 43312, "id": "b30", "idx": 30}, {"begin": 43316, "end": 43488, "id": "b31", "idx": 31}, {"begin": 43492, "end": 43659, "id": "b32", "idx": 32}, {"begin": 43663, "end": 43817, "id": "b33", "idx": 33}, {"begin": 43821, "end": 43985, "id": "b34", "idx": 34}, {"begin": 43989, "end": 44176, "id": "b35", "idx": 35}, {"begin": 44180, "end": 44372, "id": "b36", "idx": 36}, {"begin": 44376, "end": 44576, "id": "b37", "idx": 37}], "Sentence": [{"begin": 73, "end": 194, "idx": 0}, {"begin": 195, "end": 348, "idx": 1}, {"begin": 349, "end": 430, "idx": 2}, {"begin": 431, "end": 646, "idx": 3}, {"begin": 647, "end": 796, "idx": 4}, {"begin": 797, "end": 973, "idx": 5}, {"begin": 974, "end": 1337, "idx": 6}, {"begin": 1338, "end": 1460, "idx": 7}, {"begin": 1461, "end": 1567, "idx": 8}, {"begin": 1568, "end": 1647, "idx": 9}, {"begin": 1674, "end": 1863, "idx": 10}, {"begin": 1864, "end": 2059, "idx": 11}, {"begin": 2060, "end": 2145, "idx": 12}, {"begin": 2146, "end": 2280, "idx": 13}, {"begin": 2281, "end": 2403, "idx": 14}, {"begin": 2404, "end": 2608, "idx": 15}, {"begin": 2609, "end": 2764, "idx": 16}, {"begin": 2765, "end": 2961, "idx": 17}, {"begin": 2962, "end": 3179, "idx": 18}, {"begin": 3180, "end": 3380, "idx": 19}, {"begin": 3381, "end": 3639, "idx": 20}, {"begin": 3640, "end": 3709, "idx": 21}, {"begin": 3710, "end": 3904, "idx": 22}, {"begin": 3905, "end": 4065, "idx": 23}, {"begin": 4066, "end": 4134, "idx": 24}, {"begin": 4135, "end": 4323, "idx": 25}, {"begin": 4324, "end": 4519, "idx": 26}, {"begin": 4520, "end": 4714, "idx": 27}, {"begin": 4715, "end": 4897, "idx": 28}, {"begin": 4898, "end": 5087, "idx": 29}, {"begin": 5088, "end": 5239, "idx": 30}, {"begin": 5240, "end": 5369, "idx": 31}, {"begin": 5370, "end": 5600, "idx": 32}, {"begin": 5601, "end": 5777, "idx": 33}, {"begin": 5778, "end": 6011, "idx": 34}, {"begin": 6012, "end": 6187, "idx": 35}, {"begin": 6188, "end": 6420, "idx": 36}, {"begin": 6421, "end": 6594, "idx": 37}, {"begin": 6595, "end": 6787, "idx": 38}, {"begin": 6788, "end": 6931, "idx": 39}, {"begin": 6932, "end": 7053, "idx": 40}, {"begin": 7054, "end": 7332, "idx": 41}, {"begin": 7333, "end": 7596, "idx": 42}, {"begin": 7597, "end": 7880, "idx": 43}, {"begin": 7881, "end": 8054, "idx": 44}, {"begin": 8055, "end": 8192, "idx": 45}, {"begin": 8193, "end": 8335, "idx": 46}, {"begin": 8336, "end": 8382, "idx": 47}, {"begin": 8383, "end": 8599, "idx": 48}, {"begin": 8600, "end": 8756, "idx": 49}, {"begin": 8830, "end": 9031, "idx": 50}, {"begin": 9032, "end": 9213, "idx": 51}, {"begin": 9214, "end": 9383, "idx": 52}, {"begin": 9384, "end": 9682, "idx": 53}, {"begin": 9683, "end": 9899, "idx": 54}, {"begin": 9900, "end": 10009, "idx": 55}, {"begin": 10010, "end": 10158, "idx": 56}, {"begin": 10159, "end": 10277, "idx": 57}, {"begin": 10278, "end": 10415, "idx": 58}, {"begin": 10546, "end": 10758, "idx": 59}, {"begin": 10759, "end": 10813, "idx": 60}, {"begin": 10814, "end": 11007, "idx": 61}, {"begin": 11008, "end": 11078, "idx": 62}, {"begin": 11107, "end": 11252, "idx": 63}, {"begin": 11253, "end": 11361, "idx": 64}, {"begin": 11362, "end": 11526, "idx": 65}, {"begin": 11527, "end": 11616, "idx": 66}, {"begin": 11617, "end": 11831, "idx": 67}, {"begin": 11832, "end": 12055, "idx": 68}, {"begin": 12094, "end": 12233, "idx": 69}, {"begin": 12234, "end": 12390, "idx": 70}, {"begin": 12391, "end": 12485, "idx": 71}, {"begin": 12486, "end": 12721, "idx": 72}, {"begin": 12722, "end": 12893, "idx": 73}, {"begin": 12894, "end": 13107, "idx": 74}, {"begin": 13108, "end": 13298, "idx": 75}, {"begin": 13299, "end": 13355, "idx": 76}, {"begin": 13483, "end": 13582, "idx": 77}, {"begin": 13583, "end": 13660, "idx": 78}, {"begin": 13661, "end": 13806, "idx": 79}, {"begin": 13807, "end": 14076, "idx": 80}, {"begin": 14077, "end": 14323, "idx": 81}, {"begin": 14324, "end": 14563, "idx": 82}, {"begin": 14564, "end": 14698, "idx": 83}, {"begin": 14699, "end": 14848, "idx": 84}, {"begin": 14849, "end": 14937, "idx": 85}, {"begin": 14938, "end": 15128, "idx": 86}, {"begin": 15129, "end": 15280, "idx": 87}, {"begin": 15303, "end": 15390, "idx": 88}, {"begin": 15391, "end": 15476, "idx": 89}, {"begin": 15477, "end": 15491, "idx": 90}, {"begin": 15492, "end": 15493, "idx": 91}, {"begin": 15495, "end": 15659, "idx": 92}, {"begin": 15660, "end": 15719, "idx": 93}, {"begin": 15758, "end": 15831, "idx": 94}, {"begin": 15858, "end": 16008, "idx": 95}, {"begin": 16009, "end": 16121, "idx": 96}, {"begin": 16122, "end": 16250, "idx": 97}, {"begin": 16251, "end": 16423, "idx": 98}, {"begin": 16454, "end": 16516, "idx": 99}, {"begin": 16517, "end": 16610, "idx": 100}, {"begin": 16650, "end": 16801, "idx": 101}, {"begin": 16802, "end": 16916, "idx": 102}, {"begin": 16917, "end": 17111, "idx": 103}, {"begin": 17112, "end": 17137, "idx": 104}, {"begin": 17138, "end": 17338, "idx": 105}, {"begin": 17339, "end": 17443, "idx": 106}, {"begin": 17504, "end": 17567, "idx": 107}, {"begin": 17568, "end": 17602, "idx": 108}, {"begin": 17603, "end": 17761, "idx": 109}, {"begin": 17762, "end": 17868, "idx": 110}, {"begin": 17897, "end": 18086, "idx": 111}, {"begin": 18128, "end": 18170, "idx": 112}, {"begin": 18171, "end": 18226, "idx": 113}, {"begin": 18227, "end": 18255, "idx": 114}, {"begin": 18292, "end": 18448, "idx": 115}, {"begin": 18449, "end": 18596, "idx": 116}, {"begin": 18597, "end": 18768, "idx": 117}, {"begin": 18769, "end": 18913, "idx": 118}, {"begin": 18914, "end": 19075, "idx": 119}, {"begin": 19076, "end": 19216, "idx": 120}, {"begin": 19217, "end": 19237, "idx": 121}, {"begin": 19238, "end": 19409, "idx": 122}, {"begin": 19410, "end": 19561, "idx": 123}, {"begin": 19562, "end": 19587, "idx": 124}, {"begin": 19626, "end": 19716, "idx": 125}, {"begin": 19717, "end": 19906, "idx": 126}, {"begin": 19907, "end": 19969, "idx": 127}, {"begin": 19970, "end": 20147, "idx": 128}, {"begin": 20162, "end": 20252, "idx": 129}, {"begin": 20253, "end": 20455, "idx": 130}, {"begin": 20456, "end": 20579, "idx": 131}, {"begin": 20580, "end": 20770, "idx": 132}, {"begin": 20787, "end": 20940, "idx": 133}, {"begin": 20966, "end": 21044, "idx": 134}, {"begin": 21076, "end": 21207, "idx": 135}, {"begin": 21208, "end": 21341, "idx": 136}, {"begin": 21342, "end": 21459, "idx": 137}, {"begin": 21460, "end": 21553, "idx": 138}, {"begin": 21554, "end": 21699, "idx": 139}, {"begin": 21700, "end": 21826, "idx": 140}, {"begin": 21827, "end": 21871, "idx": 141}, {"begin": 21872, "end": 21982, "idx": 142}, {"begin": 22006, "end": 22170, "idx": 143}, {"begin": 22171, "end": 22416, "idx": 144}, {"begin": 22417, "end": 22620, "idx": 145}, {"begin": 22621, "end": 22761, "idx": 146}, {"begin": 22762, "end": 22924, "idx": 147}, {"begin": 22925, "end": 22996, "idx": 148}, {"begin": 22997, "end": 23179, "idx": 149}, {"begin": 23180, "end": 23349, "idx": 150}, {"begin": 23350, "end": 23514, "idx": 151}, {"begin": 23547, "end": 23652, "idx": 152}, {"begin": 23653, "end": 23816, "idx": 153}, {"begin": 23817, "end": 23979, "idx": 154}, {"begin": 23980, "end": 23996, "idx": 155}, {"begin": 23997, "end": 24128, "idx": 156}, {"begin": 24129, "end": 24247, "idx": 157}, {"begin": 24277, "end": 24355, "idx": 158}, {"begin": 24356, "end": 24489, "idx": 159}, {"begin": 24490, "end": 24663, "idx": 160}, {"begin": 24664, "end": 24797, "idx": 161}, {"begin": 24798, "end": 24888, "idx": 162}, {"begin": 24911, "end": 25052, "idx": 163}, {"begin": 25053, "end": 25178, "idx": 164}, {"begin": 25179, "end": 25335, "idx": 165}, {"begin": 25336, "end": 25397, "idx": 166}, {"begin": 25398, "end": 25519, "idx": 167}, {"begin": 25520, "end": 25670, "idx": 168}, {"begin": 25671, "end": 25811, "idx": 169}, {"begin": 25812, "end": 25931, "idx": 170}, {"begin": 25932, "end": 26086, "idx": 171}, {"begin": 26087, "end": 26301, "idx": 172}, {"begin": 26302, "end": 26514, "idx": 173}, {"begin": 26515, "end": 26700, "idx": 174}, {"begin": 26701, "end": 26893, "idx": 175}, {"begin": 26894, "end": 27157, "idx": 176}, {"begin": 27158, "end": 27359, "idx": 177}, {"begin": 27360, "end": 27550, "idx": 178}, {"begin": 27551, "end": 27703, "idx": 179}, {"begin": 27704, "end": 27958, "idx": 180}, {"begin": 27959, "end": 28017, "idx": 181}, {"begin": 28018, "end": 28147, "idx": 182}, {"begin": 28184, "end": 28402, "idx": 183}, {"begin": 28403, "end": 28475, "idx": 184}, {"begin": 28476, "end": 28612, "idx": 185}, {"begin": 28613, "end": 28813, "idx": 186}, {"begin": 28814, "end": 28856, "idx": 187}, {"begin": 28857, "end": 28940, "idx": 188}, {"begin": 28941, "end": 29207, "idx": 189}, {"begin": 29208, "end": 29259, "idx": 190}, {"begin": 29293, "end": 29450, "idx": 191}, {"begin": 29451, "end": 29620, "idx": 192}, {"begin": 29621, "end": 29761, "idx": 193}, {"begin": 29762, "end": 29878, "idx": 194}, {"begin": 29879, "end": 30104, "idx": 195}, {"begin": 30105, "end": 30239, "idx": 196}, {"begin": 30240, "end": 30359, "idx": 197}, {"begin": 30360, "end": 30475, "idx": 198}, {"begin": 30476, "end": 30615, "idx": 199}, {"begin": 30616, "end": 30828, "idx": 200}, {"begin": 30829, "end": 31009, "idx": 201}, {"begin": 31010, "end": 31138, "idx": 202}, {"begin": 31139, "end": 31250, "idx": 203}, {"begin": 31251, "end": 31434, "idx": 204}, {"begin": 31435, "end": 31534, "idx": 205}, {"begin": 31535, "end": 31694, "idx": 206}, {"begin": 31695, "end": 31890, "idx": 207}, {"begin": 31891, "end": 32029, "idx": 208}, {"begin": 32030, "end": 32196, "idx": 209}, {"begin": 32197, "end": 32328, "idx": 210}, {"begin": 32329, "end": 32574, "idx": 211}, {"begin": 32575, "end": 32740, "idx": 212}, {"begin": 32741, "end": 33030, "idx": 213}, {"begin": 33031, "end": 33154, "idx": 214}, {"begin": 33155, "end": 33273, "idx": 215}, {"begin": 33274, "end": 33326, "idx": 216}, {"begin": 33327, "end": 33492, "idx": 217}, {"begin": 33518, "end": 33695, "idx": 218}, {"begin": 33696, "end": 34096, "idx": 219}, {"begin": 34097, "end": 34184, "idx": 220}, {"begin": 34185, "end": 34259, "idx": 221}, {"begin": 34260, "end": 34401, "idx": 222}, {"begin": 34402, "end": 34617, "idx": 223}, {"begin": 34618, "end": 34826, "idx": 224}, {"begin": 34827, "end": 34969, "idx": 225}, {"begin": 34970, "end": 35165, "idx": 226}, {"begin": 35192, "end": 35384, "idx": 227}, {"begin": 35385, "end": 35529, "idx": 228}, {"begin": 35530, "end": 35851, "idx": 229}, {"begin": 35852, "end": 36109, "idx": 230}, {"begin": 36110, "end": 36379, "idx": 231}, {"begin": 36380, "end": 36728, "idx": 232}, {"begin": 36729, "end": 36937, "idx": 233}], "ReferenceToFigure": [{"begin": 3177, "end": 3178, "idx": 0}, {"begin": 9618, "end": 9619, "idx": 1}], "Abstract": [{"begin": 63, "end": 1647, "idx": 0}], "SectionFootnote": [{"begin": 36939, "end": 37089, "idx": 0}], "Footnote": [{"begin": 36950, "end": 37019, "id": "foot_0", "n": "1", "idx": 0}, {"begin": 37020, "end": 37089, "id": "foot_1", "n": "2", "idx": 1}]}}