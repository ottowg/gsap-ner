{"text": "CodeBERT: A Pre-Trained Model for Programming and Natural Languages\n\nAbstract:\nWe present CodeBERT, a bimodal pre-trained model for programming language (PL) and natural language (NL). CodeBERT learns general-purpose representations that support downstream NL-PL applications such as natural language code search, code documentation generation, etc. We develop Code-BERT with Transformer-based neural architecture, and train it with a hybrid objective function that incorporates the pre-training task of replaced token detection, which is to detect plausible alternatives sampled from generators. This enables us to utilize both \"bimodal\" data of NL-PL pairs and \"unimodal\" data, where the former provides input tokens for model training while the latter helps to learn better generators. We evaluate CodeBERT on two NL-PL applications by fine-tuning model parameters. Results show that CodeBERT achieves state-of-the-art performance on both natural language code search and code documentation generation. Furthermore, to investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and evaluate in a zero-shot setting where parameters of pre-trained models are fixed. Results show that CodeBERT performs better than previous pre-trained models on NL-PL probing. 1\n\n\n1 Introduction\nLarge pre-trained models such as ELMo (Peters et al., 2018), GPT (Radford et al., 2018), BERT (Devlin et al., 2018), XLNet (Yang et al., 2019) and RoBERTa (Liu et al., 2019) have dramatically improved the state-of-the-art on a variety of natural language processing (NLP) tasks. These pre-trained models learn effective contextual representations from massive unlabeled text optimized by self-supervised objectives, such as masked language modeling, which predicts the original masked word from an artificially masked input sequence. The success of pre-trained models in NLP also drives a surge of multi-modal pre-trained models, such as ViLBERT (Lu et al., 2019) for language-image and VideoBERT (Sun et al., 2019) for language-video, which are learned from bimodal data such as language-image pairs with bimodal self-supervised objectives.\nIn this work, we present CodeBERT, a bimodal pre-trained model for natural language (NL) and programming language (PL) like Python, Java, JavaScript, etc. CodeBERT captures the semantic connection between natural language and programming language, and produces general-purpose representations that can broadly support NL-PL understanding tasks (e.g. natural language code search) and generation tasks (e.g. code documentation generation). It is developed with the multilayer Transformer (Vaswani et al., 2017), which is adopted in a majority of large pre-trained models. In order to make use of both bimodal instances of NL-PL pairs and large amount of available unimodal codes, we train CodeBERT with a hybrid objective function, including standard masked language modeling (Devlin et al., 2018) and replaced token detection (Clark et al., 2020), where unimodal codes help to learn better generators for producing better alternative tokens for the latter objective.\nWe train CodeBERT from Github code reposito-ries in 6 programming languages, where bimodal datapoints are codes that pair with function-level natural language documentations (Husain et al., 2019). Training is conducted in a setting similar to that of multilingual BERT (Pires et al., 2019), in which case one pre-trained model is learned for 6 programming languages with no explicit markers used to denote the input programming language. We evaluate CodeBERT on two downstream NL-PL tasks, including natural language code search and code documentation generation.\nResults show that fine-tuning the parameters of CodeBERT achieves state-of-the-art performance on both tasks. To further investigate what type of knowledge is learned in CodeBERT, we construct a dataset for NL-PL probing, and test CodeBERT in a zero-shot scenario, i.e. without fine-tuning the parameters of CodeBERT. We find that CodeBERT consistently outperforms RoBERTa, a purely natural language-based pre-trained model. The contributions of this work are as follows:\n\u2022 CodeBERT is the first large NL-PL pretrained model for multiple programming languages.\n\u2022 Empirical results show that CodeBERT is effective in both code search and code-to-text generation tasks.\n\u2022 We further created a dataset which is the first one to investigate the probing ability of the code-based pre-trained models.\n\n2 Background\n2.1 Pre-Trained Models in NLP Large pre-trained models (Peters et al., 2018; Radford et al., 2018; Devlin et al., 2018; Yang et al., 2019; Liu et al., 2019; Raffel et al., 2019) have brought dramatic empirical improvements on almost every NLP task in the past few years. Successful approaches train deep neural networks on large-scale plain texts with self-supervised learning objectives. One of the most representative neural architectures is the Transformer (Vaswani et al., 2017), which is also the one used in this work. It contains multiple self-attention layers, and can be conventionally learned with gradient decent in an end-to-end manner as every component is differentiable. The terminology \"self-supervised\" means that supervisions used for pre-training are automatically collected from raw data without manual annotation. Dominant learning objectives are language modeling and its variations. For example, in GPT (Radford et al., 2018), the learning objective is language modeling, namely predicting the next word w k given the preceding context words {w 1 , w 2 , ..., w k\u22121 }. As the ultimate goal of pretraining is not to train a good language model, it is desirable to consider both preceding and following contexts to learn better general-purpose contextual representations. This leads us to the masked language modeling objective used in BERT (Devlin et al., 2018), which learns to predict the masked words of a randomly masked word sequence given surrounding contexts. Masked language modeling is also used as one of the two learning objectives for training CodeBERT.\n\n2.2 Multi-Modal Pre-Trained Models\nThe remarkable success of the pre-trained model in NLP has driven the development of multi-modal pre-trained model that learns implicit alignment between inputs of different modalities. These models are typically learned from bimodal data, such as pairs of language-image or pairs of languagevideo. For example, ViLBERT (Lu et al., 2019) learns from image caption data, where the model learns by reconstructing categories of masked image region or masked words given the observed inputs, and meanwhile predicting whether the caption describes the image content or not. Similarly, VideoBERT (Sun et al., 2019) learns from language-video data and is trained by video and text masked token prediction. Our work belongs to this line of research as we regard NL and PL as different modalities. Our method differs from previous works in that the fuels for model training include not only bimodal data of NL-PL pairs, but larger amounts of unimodal data such as codes without paired documentations. A concurrent work (Kanade et al., 2019) uses masked language modeling and next sentence prediction as the objective to train a BERT model on Python source codes, where a sentence is a logical code line as defined by the Python standard. In terms of the pre-training process, CodeBERT differs from their work in that (1) CodeBERT is trained in a cross-modal style and leverages both bimodal NL-PL data and unimodal PL/NL data, (2) CodeBERT is pre-trained over six programming languages, and (3) CodeBERT is trained with a new learning objective based on replaced token detection.\n\n3 CodeBERT\nWe describe the details about CodeBERT in this section, including the model architecture, the input and output representations, the objectives and data used for training CodeBERT, and how to fine-tune CodeBERT when it is applied to downstream tasks.\n\n3.1 Model Architecture\nWe follow BERT (Devlin et al., 2018) and RoBERTa (Liu et al., 2019), and use multi-layer bidirectional Transformer (Vaswani et al., 2017) as the model architecture of CodeBERT. We will not review the ubiquitous Transformer architecture in detail. We develop CodeBERT by using exactly the same model architecture as RoBERTa-base. The total number of model parameters is 125M.\n\n3.2 Input/Output Representations\nIn the pre-training phase, we set the input as the concatenation of two segments with a special separator token, namely[CLS], w 1 , w 2 , ..w n , [SEP ], c 1 , c 2 , ..., c m , [EOS].\nOne segment is natural language text, and another is code from a certain programming language.\n[CLS] is a special token in front of the two segments, whose final hidden representation is considered as the aggregated sequence representation for classification or ranking. Following the standard way of processing text in Transformer, we regard a natural language text as a sequence of words, and split it as WordPiece (Wu et al., 2016). We regard a piece of code as a sequence of tokens.\nThe output of CodeBERT includes (1) contextual vector representation of each token, for both natural language and code, and (2) the representation of [CLS], which works as the aggregated sequence representation.\n\n3.3 Pre-Training Data\nWe train CodeBERT with both bimodal data, which refers to parallel data of natural language-code pairs, and unimodal data, which stands for codes without paired natural language texts and natural language without paired codes.\nWe use datapoints from Github repositories, where each bimodal datapoint is an individual function with paired documentation, and each unimodal code is a function without paired documentation. Specifically, we use a recent large dataset provided by Husain et al. (2019), which includes 2.1M bimodal datapoints and 6.4M unimodal codes across six programming languages (Python, Java, JavaScript, PHP, Ruby, and Go). Data statistics is shown in Table 1. 2 he data comes from publicly available opensource non-fork GitHub repositories and are filtered with a set of constraints and rules. For example, (1) each project should be used by at least one other project, (2) each documentation is truncated to the first paragraph, (3) documentations shorter than three tokens are removed, (4) functions shorter than three lines are removed, and (5) function names with substring \"test\" are removed. An example of the data is given in Figure 1 3.\n\n3.4 Pre-Training CodeBERT\nWe describe the two objectives used for training CodeBERT here. The first objective is masked language modeling (MLM), which has proven effective in literature (Devlin et al., 2018; Liu et al., NL Generator 2019; Sun et al., 2019). We apply masked language modeling on bimodal data of NL-PL pairs. The second objective is replaced token detection (RTD), which further uses a large amount of unimodal data, such as codes without paired natural language texts. Detailed hyper-parameters for model pre-training are given in Appendix B.1.\n\nNL-Code Discriminator\nObjective #1: Masked Language Modeling (MLM) Given a datapoint of NL-PL pair (x = {w, c}) as input, where w is a sequence of NL words and c is a sequence of PL tokens, we first select a random set of positions for both NL and PL to mask out (i.e. m w and m c , respectively), and then replace the selected positions with a special [M ASK] token. Following Devlin et al. (2018), 15% of the tokens from x are masked out.m w i \u223c unif{1, |w|} for i = 1 to |w| (1) m c i \u223c unif{1, |c|} for i = 1 to |c| (2)w masked = REPLACE(w, m w , [M ASK]) (3) c masked = REPLACE(c, m c , [M ASK]) (4) x = w + c (5)\nThe MLM objective is to predict the original tokens which are masked out, formulated as follows, where p D 1 is the discriminator which predicts a token from a large vocabulary.L MLM (\u03b8) = i\u2208m w \u222am c \u2212log p D 1 (x i |w masked ,c masked ) (6)\nObjective #2: Replaced Token Detection (RTD)\nIn the MLM objective, only bimodal data (i.e. datapoints of NL-PL pairs) is used for training. Here we present the objective of replaced token detection. The RTD objective (Clark et al., 2020) is originally developed for efficiently learning pre-trained model for natural language. We adapt it in our scenario, with the advantage of using both bimodal and unimodal data for training. Specifically, there are two data generators here, an NL generator p Gw and a PL generator p Gc , both for generating plausible alternatives for the set of randomly masked positions.\u0175i \u223c p Gw (w i |w masked ) for i \u2208 m w (7) \u0109i \u223c p Gc (c i |c masked ) for i \u2208 m c (8) w corrupt = REPLACE(w, m w , \u0175) (9) c corrupt = REPLACE(c, m c , \u0109) (10) x corrupt = w corrupt + c corrupt (11)\nThe discriminator is trained to determine whether a word is the original one or not, which is a binary classification problem. It is worth noting that the RTD objective is applied to every position in the input, and it differs from GAN (generative adversarial network) in that if a generator happens to produce the correct token, the label of that token is \"real\" instead of \"fake\" (Clark et al., 2020). The loss function of RTD with regard to the discriminator parameterized by \u03b8 is given below, where \u03b4(i) is an indicator function and p D 2 is the discriminator that predicts the probability of the i-th word being original.L RTD (\u03b8) = |w|+|c| i=1 \u03b4(i)log p D 2 (x corrupt , i)+ 1 \u2212 \u03b4(i) 1 \u2212 log p D 2 (x corrupt , i)\u03b4(i) = 1, if x corrupt i = x i . 0, otherwise. ()\nThere are many different ways to implement the generators. In this work, we implement two efficient n-gram language models (Jurafsky, 2000) with bidirectional contexts, one for NL and one for PL, and learn them from corresponding unimodel datapoints, respectively. The approach is easily generalized to learn bimodal generators or use more complicated generators like Transformerbased neural architecture learned in a joint manner. We leave these to future work. The PL training data is the unimodal codes as shown in Table 1, and the NL training data comes from the documentations from bimodal data. One could easily extend these two training datasets to larger amount. The final loss function are given below.min \u03b8 L MLM (\u03b8) + L RTD (\u03b8) (14)\n\n3.5 Fine-Tuning CodeBERT\nWe have different settings to use CodeBERT in downstream NL-PL tasks. For example, in natural language code search, we feed the input as the same way as the pre-training phase and use the representation of [CLS] to measure the semantic relevance between code and natural language query, while in code-to-text generation, we use an encoderdecoder framework and initialize the encoder of a generative model with CodeBERT. Details are given in the experiment section.\n\n4 Experiment\nWe present empirical results in this section to verify the effectiveness of CodeBERT. We first describe the use of CodeBERT in natural language code search ( \u00a74.1), in a way that model parameters of CodeBERT are fine-tuned. After that, we present the NL-PL probing task ( \u00a74.2), and evaluate Code-BERT in a zero-shot setting where the parameters of CodeBERT are fixed. Finally, we evaluate Code-BERT on a generation problem, i.e. code documentation generation ( \u00a74.3), and further evaluate on a programming language which is never seen in the training phase ( \u00a74.4).\n\n4.1 Natural Language Code Search\nGiven a natural language as the input, the objective of code search is to find the most semantically related code from a collection of codes. We conduct experiments on the CodeSearchNet corpus (Husain et al., 2019) 4. We follow the official evaluation metric to calculate the Mean Reciprocal Rank (MRR) for each pair of test data (c, w) over a fixed set of 999 distractor codes. We further calculate the macro-average MRR for all languages as an overall evaluation metric. It is helpful to note that this metric differs from the AVG metric in the original paper, where the answer is retrieved from candidates from all six languages. We fine-tune a languagespecific model for each programming language 5. We train each model with a binary classification loss function, where a sof tmax layer is connected to the representation of\n\nModel Comparisons\nTable 2 shows the results of different approaches on the CodeSearchNet corpus. The first four rows are reported by Husain et al. (2019), which are joint embeddings of NL and PL (Gu et al., 2018; Mitra et al., 2018). NBOW represents neural bag-of-words. CNN, BIRNN and SELFATT stand for 1D convolultional neural network (Kim, 2014), bidirectional GRU-based recurrent neural network (Cho et al., 2014), and multi-head attention (Vaswani et al., 2017), respectively.\nWe report the remaining numbers in Table 2. We train all these pre-trained models by regarding codes as a sequence of tokens. We also continuously train RoBERTa only on codes from Code-SearchNet with masked language modeling. Results show that CodeBERT consistently performs better than RoBERTa and the model pre-trained with code only. CodeBERT (MLM) learned from scratch performs better than RoBERTa. Unsurprisingly, initializing CodeBERT with RoBERTa improves the performance 6.\n\n4.2 NL-PL Probing\nIn the previous subsection, we show the empirical effectiveness of CodeBERT in a setting that the parameters of CodeBERT are fine-tuned in downstream tasks. In this subsection, we further investigate what type of knowledge is learned in Code-BERT without modifying the parameters.\nTask Formulation and Data Construction Following the probing experiments in NLP (Petroni et al., 2019; Talmor et al., 2019), we study NL-PL probing here. Since there is no existing work towards this goal, we formulate the problem of NL-PL probing and create the dataset by ourselves. Given an NL-PL pair (c, w), the goal of NL-PL probing is to test model's ability to correctly predict/recover the masked token of interest (either a code token c i or word token w j ) among distractors.\nThere are two major types of distractors: one is the whole target vocabulary used for the masked language modeling objective (Petroni et al., 2019), and another one has fewer candidates which are filter or curated based on experts' understanding about the ability to be tested (Talmor et al., 2019). We follow the second direction and formulate NL-PL probing as a multi-choice question answering task, where the question is cloze-style in which a certain token is replaced by [M ASK] and distractor candidate answers are curated based on our expertise. Specifically, we evaluate on the NL side and PL side, respectively. To ease the effort of data collection, we collect data automatically from NL-PL pairs in both validation and testing sets of Code-SearchNet, both of which are unseen in the pretraining phase. To evaluate on the NL side, we select NL-PL pairs whose NL documentations include one of the six keywords (max, maximize, min, minimize, less, greater), and group them to four candidates by merging first two keywords and the middle two keywords. The task is to ask pre-trained models to select the correct one instead of three other distractors. That is to say, the input in this setting includes the complete code and a masked NL documentation. The goal is to select the correct answer from four candidates. For the PL side, we select codes containing keywords max and min, and formulate the task as a two-choice answer selection problem. Here, the input includes complete NL documentation and a masked PL code, and the goal is to select the correct answer from two candidates. Since code completion is an important scenario, we would like to test model's ability in predicting the correct token merely based on preceding PL contexts. Therefore, we add an additional setting for PL side, where the input includes the complete NL documentation and preceding PL codes. Data statistics is given in the top two rows in Table 3.\n\nModel Comparisons\nResults are given in Table 3. We report accuracy, namely the number of correctly predicted instances over the number of all instances, for each programming language. Since  datasets in different programming languages are extremely unbalanced, we report the accumulated metric with the same way. We use CodeBERT (MLM) here because its output layer naturally fits for probing. Results show that CodeBERT performs better than baselines on almost all languages on both NL and PL probing. The numbers with only preceding contexts are lower than that with bidirectional contexts, which suggests that code completion is challenging. We leave it as a future work.\nWe further give a case study on PL-NL probing. We mask NL token and PL token separately, and report the predicted probabilities of RoBERTa and CodeBERT. Figure 3 illustrates the example of a python code 7 . We can see that RoBERTa fails in both cases, whereas CodeBERT makes the correct prediction in both NL and PL settings.\n\n4.3 Code Documentation Generation\nAlthough the pre-training objective of Code-BERT does not include generation-based objectives (Lewis et al., 2019), we would like to investigate to what extent does CodeBERT perform on generation tasks. Specifically, we study code-to-NL generation, and report results for the documentation generation task on CodeSearchNet Corpus in six programming languages. Since the generated documentations are short and higher order n-grams may not overlap, we remedy this problem by using smoothed BLEU score (Lin and Och, 2004). 7 The example comes from https:// github.com/peri-source/peri/blob/ 61beed5deaaf978ab31ed716e8470d86ba639867/ peri/comp/psfcalc.py#L994-L1002 def vec_to_halfvec(vec):d = vec[1:] -vec[:-1] if ((d/d.mean()).std() >\n\nModel Comparisons\nWe compare our model with several baselines, including a RNN-based model with attention mechanism (Sutskever et al., 2014), the Transformer (Vaswani et al., 2017), RoBERTa and the model pre-trained on code only.\nTo demonstrate the effectiveness of CodeBERT on code-to-NL generation tasks, we adopt various pre-trained models as encoders and keep the hyperparameters consistent. Detailed hyper-parameters are given in Appendix B.3. Table 4 shows the results with different models for the code-to-documentation generation task. As we can see, models pre-trained on programming language outperform RoBERTa, which illustrates that pre-trainning models on programming  However, our model achieve slightly lower results than code2seq (Alon et al., 2019). The main reason could be that code2seq makes use of compositional paths in its abstract syntax tree (AST) while Code-BERT only takes original code as the input. We have trained a version of CodeBERT by traversing the tree structure of AST following a certain order, but applying that model does not bring improvements on generation tasks. This shows a potential direction to improve CodeBERT by incorporating AST.\n\n5 Conclusion\nIn this paper, we present CodeBERT, which to the best of our knowledge is the first large bimodal pre-trained model for natural language and programming language. We train CodeBERT on both bimodal and unimodal data, and show that finetuning CodeBERT achieves state-of-the-art performance on downstream tasks including natural language code search and code-to-documentation generation. To further investigate the knowledge embodied in pre-trained models, we formulate the task of NL-PL probing and create a dataset for probing. We regard the probing task as a cloze-style answer selection problem, and curate distractors for both NL and PL parts. Results show that, with model parameters fixed, CodeBERT performs better than RoBERTa and a continuously trained model using codes only.\nThere are many potential directions for further research on this field. First, one could learn better generators with bimodal evidence or more complicated neural architecture to improve the replaced token detection objective. Second, the loss functions of CodeBERT mainly target on NL-PL understanding tasks. Although CodeBERT achieves strong BLEU scores on code-to-documentation generation, the CodeBERT itself could be further improved by generation-related learning objectives.\nHow to successfully incorporate AST into the pretraining step is also an attractive direction. Third, we plan to apply CodeBERT to more NL-PL related tasks, and extend it to more programming languages. Flexible and powerful domain/language adaptation methods are necessary to generalize well.\n\nA Data Statistic\nData statistics of the training/validation/testing data splits for six programming languages are given in Table 6.\n\nB.2 CodeSearch\nIn the fine-turning step, we set the learning rate as 1e-5, the batch size as 64, the max sequence length as 200 and the max fine-tuning epoch as 8. As the same with pre-training, We use Adam to update the parameters. We choose the model performed best on the development set, and use that to evaluate on the test set.\n\nB.3 Code Summarization on Six Programming Languages\nWe use Transformer with 6 layers, 768 dimensional hidden states and 12 attention heads as our decoder in all settings. We set the max length of input and inference as 256 and 64, respectively. We use the Adam optimizer to update model parameters.\nThe learning rate and the batch size are 5e-5 and 64, respectively. We tune hyperparameters and perform early stopping on the development set.\n\nB.4 Code Summarization on C#\nSince state-of-the-art methods use RNN as their decoder, we choose a 2-layer GRU with an attention mechanism as our decoder for a comparison. We fine-tune models using a grid search with the following set of hyper-parameters: batchsize is in {32, 64} and learning rate is in {2e-5, 5e-5}. We report the number when models achieve best performance on the development set.\n\nC Learning Curve of CodeSearch\nFrom Figure 4, we can see that CodeBERT performs better at the early stage, which reflects that CodeBERT provides good initialization for learning downstream tasks.\n\nD Late Fusion\nIn section \u00a74.1 , we show that CodeBERT performs well in the setting where natural languages and codes have early interactions. Here, we investigate whether CodeBERT is good at working as a unified encoder. We apply CodeBERT for natural language code search in a later fusion setting, where CodeBERT first encodes NL and PL separately, and then calculates the similarity by dotproduct. In this way, code search is equivalent to find the nearest codes in the shared vector space. This scenario also facilitates the use of CodeBERT in an online system, where the representations of codes are calculated in advance. In the runtime, a system only needs to compute the representation of NL and vector-based dot-product.\nWe fine-tune CodeBERT with the following objective, which maximizes the dot-product of the ground truth while minimizing the dot-product of distractors.\n\n\u2212\n1 N i log exp Enc(c i ) Enc(w i ) j exp Enc(c j ) Enc(w i )\nResults are given in Table 7. We just do this setting on two languages with a relatively small amount of data.\nWe can see that CodeBERT performs better than RoBERTa and the model pre-trained with codes only. And late fusion performs comparable with the standard way. What's more, late fusion is more efficient and this setting could be used in an online system.\n\nE Case Study\nTo qualitatively analyze the effectiveness of Code-BERT, we give some cases for code search and code documentation generation tasks.\nConsidering the limited space, we only give the top2 results of the query for python programming language. As show in Figure 5, search results are very relevant with query.\nFigure 6 and Figure 7 show the outputs with different models for the code documentation generation task. As we can see, CodeBERT performs better than all baselines.\n\nFootnotes:\n1: All the codes and data are available at https:// github.com/microsoft/CodeBERT\n2: Since we will evaluate on the natural language code search task, we only use the training data of Husain et al. (2019) to train CodeBERT with no access to the dev and testing data.\n3: 3  The source of the illustrating example comes from https://github.com/apache/spark/blob/ 618d6bff71073c8c93501ab7392c3cc579730f0b/ python/pyspark/rdd.py#L125-L138\n4: More details about the dataset are given in Appendix A.\n5: We have fine-tuned a multi-lingual model for six programming languages, but find that it performs worse that fine-tuning a language-specific model for each programming language.\n6: We further give a learning curve of different pre-trained models in the fine-tuning process in Appendix C.\n8: We further give some output examples in Appendix E.\n9: https://github.com/sriniiyer/codenn\n\nReferences:\n\n- Uri Alon, Shaked Brody, Omer Levy, and Eran Yahav. 2019. code2seq: Generating sequences from struc- tured representations of code. International Confer- enceon Learning Representations.- Kyunghyun Cho, Bart Van Merri\u00ebnboer, Caglar Gul- cehre, Dzmitry Bahdanau, Fethi Bougares, Holger Schwenk, and Yoshua Bengio. 2014. Learning phrase representations using rnn encoder-decoder for statistical machine translation. arXiv preprint arXiv:1406.1078.\n\n- Kevin Clark, Minh-Thang Luong, Quoc V. Le, and Christopher D. Manning. 2020. {ELECTRA}: Pre- training text encoders as discriminators rather than generators. In International Conference on Learn- ing Representations.\n\n- Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert: Pre-training of deep bidirectional transformers for language understand- ing. arXiv preprint arXiv:1810.04805.\n\n- Xiaodong Gu, Hongyu Zhang, and Sunghun Kim. 2018. Deep code search. In 2018 IEEE/ACM 40th Interna- tional Conference on Software Engineering (ICSE), pages 933-944. IEEE.\n\n- Hamel Husain, Ho-Hsiang Wu, Tiferet Gazit, Miltiadis Allamanis, and Marc Brockschmidt. 2019. Code- searchnet challenge: Evaluating the state of seman- tic code search. arXiv preprint arXiv:1909.09436.\n\n- Srinivasan Iyer, Ioannis Konstas, Alvin Cheung, and Luke Zettlemoyer. 2016. Summarizing source code using a neural attention model. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 2073-2083.\n\n- Dan Jurafsky. 2000. Speech & language processing. Pearson Education India.\n\n- Aditya Kanade, Petros Maniatis, Gogul Balakrish- nan, and Kensen Shi. 2019. Pre-trained contex- tual embedding of source code. arXiv preprint arXiv:2001.00059.\n\n- Yoon Kim. 2014. Convolutional neural net- works for sentence classification. arXiv preprint arXiv:1408.5882.\n\n- Philipp Koehn, Hieu Hoang, Alexandra Birch, Chris Callison-Burch, Marcello Federico, Nicola Bertoldi, Brooke Cowan, Wade Shen, Christine Moran, Richard Zens, et al. 2007. Moses: Open source toolkit for statistical machine translation. In Pro- ceedings of the 45th annual meeting of the associ- ation for computational linguistics companion vol- ume proceedings of the demo and poster sessions, pages 177-180.\n\n- Mike Lewis, Yinhan Liu, Naman Goyal, Mar- jan Ghazvininejad, Abdelrahman Mohamed, Omer Levy, Ves Stoyanov, and Luke Zettlemoyer. 2019. Bart: Denoising sequence-to-sequence pre-training for natural language generation, translation, and comprehension. arXiv preprint arXiv:1910.13461.\n\n- Chin-Yew Lin and Franz Josef Och. 2004. Orange: a method for evaluating automatic evaluation metrics for machine translation. In Proceedings of the 20th international conference on Computational Linguis- tics, page 501. Association for Computational Lin- guistics.\n\n- Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Man- dar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, and Veselin Stoyanov. 2019. Roberta: A robustly optimized bert pretraining ap- proach. arXiv preprint arXiv:1907.11692.\n\n- Jiasen Lu, Dhruv Batra, Devi Parikh, and Stefan Lee. 2019. Vilbert: Pretraining task-agnostic visi- olinguistic representations for vision-and-language tasks. In Advances in Neural Information Process- ing Systems, pages 13-23.\n\n- Bhaskar Mitra, Nick Craswell, et al. 2018. An intro- duction to neural information retrieval. Foundations and Trends R in Information Retrieval, 13(1):1-126.\n\n- Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep contextualized word repre- sentations. arXiv preprint arXiv:1802.05365.\n\n- Fabio Petroni, Tim Rockt\u00e4schel, Patrick Lewis, Anton Bakhtin, Yuxiang Wu, Alexander H Miller, and Se- bastian Riedel. 2019. Language models as knowl- edge bases? arXiv preprint arXiv:1909.01066.\n\n- Telmo Pires, Eva Schlinger, and Dan Garrette. 2019. How multilingual is multilingual bert? arXiv preprint arXiv:1906.01502.\n\n- Alec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. Improving language understanding by generative pre-training. URL https://s3-us-west-2. amazonaws. com/openai- assets/researchcovers/languageunsupervised/language understanding paper. pdf.\n\n- Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang, Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2019. Exploring the limits of transfer learning with a unified text-to-text trans- former. arXiv preprint arXiv:1910.10683.\n\n- Alexander M Rush, Sumit Chopra, and Jason We- ston. 2015. A neural attention model for ab- stractive sentence summarization. arXiv preprint arXiv:1509.00685.\n\n- Chen Sun, Austin Myers, Carl Vondrick, Kevin Mur- phy, and Cordelia Schmid. 2019. Videobert: A joint model for video and language representation learn- ing. arXiv preprint arXiv:1904.01766.\n\n- Ilya Sutskever, Oriol Vinyals, and Quoc V Le. 2014. Sequence to sequence learning with neural networks. In Advances in neural information processing sys- tems, pages 3104-3112.\n\n- Kai Sheng Tai, Richard Socher, and Christopher D Manning. 2015. Improved semantic representations from tree-structured long short-term memory net- works. arXiv preprint arXiv:1503.00075.\n\n- Alon Talmor, Yanai Elazar, Yoav Goldberg, and Jonathan Berant. 2019. olmpics-on what lan- guage model pre-training captures. arXiv preprint arXiv:1912.13283.\n\n- Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, \u0141ukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in neural information pro- cessing systems, pages 5998-6008.\n\n- Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi, Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al. 2016. Google's neural machine translation system: Bridging the gap between hu- man and machine translation. arXiv preprint arXiv:1609.08144.\n\n- Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Car- bonell, Ruslan Salakhutdinov, and Quoc V Le. 2019. Xlnet: Generalized autoregressive pretrain- ing for language understanding. arXiv preprint arXiv:1906.08237.\n\n", "annotations": {"Abstract": [{"begin": 69, "end": 1304, "idx": 0}], "Head": [{"begin": 1307, "end": 1321, "n": "1", "idx": 0}, {"begin": 4491, "end": 4503, "n": "2", "idx": 1}, {"begin": 6093, "end": 6127, "n": "2.2", "idx": 2}, {"begin": 7700, "end": 7710, "n": "3", "idx": 3}, {"begin": 7962, "end": 7984, "n": "3.1", "idx": 4}, {"begin": 8361, "end": 8393, "n": "3.2", "idx": 5}, {"begin": 9278, "end": 9299, "n": "3.3", "idx": 6}, {"begin": 10464, "end": 10489, "n": "3.4", "idx": 7}, {"begin": 11026, "end": 11047, "idx": 8}, {"begin": 14209, "end": 14233, "n": "3.5", "idx": 9}, {"begin": 14700, "end": 14712, "n": "4", "idx": 10}, {"begin": 15281, "end": 15313, "n": "4.1", "idx": 11}, {"begin": 16144, "end": 16161, "idx": 12}, {"begin": 17109, "end": 17126, "n": "4.2", "idx": 13}, {"begin": 19834, "end": 19851, "idx": 14}, {"begin": 20835, "end": 20868, "n": "4.3", "idx": 15}, {"begin": 21603, "end": 21620, "idx": 16}, {"begin": 22785, "end": 22797, "n": "5", "idx": 17}, {"begin": 24356, "end": 24372, "idx": 18}, {"begin": 24489, "end": 24503, "idx": 19}, {"begin": 24824, "end": 24875, "idx": 20}, {"begin": 25267, "end": 25295, "idx": 21}, {"begin": 25668, "end": 25698, "idx": 22}, {"begin": 25865, "end": 25878, "idx": 23}, {"begin": 26748, "end": 26749, "idx": 24}, {"begin": 27173, "end": 27185, "idx": 25}], "ReferenceToBib": [{"begin": 1360, "end": 1381, "target": "#b16", "idx": 0}, {"begin": 1387, "end": 1409, "target": "#b19", "idx": 1}, {"begin": 1416, "end": 1437, "target": "#b3", "idx": 2}, {"begin": 1445, "end": 1464, "target": "#b28", "idx": 3}, {"begin": 1477, "end": 1495, "target": "#b13", "idx": 4}, {"begin": 1968, "end": 1985, "target": "#b14", "idx": 5}, {"begin": 2019, "end": 2037, "target": "#b22", "idx": 6}, {"begin": 2651, "end": 2673, "target": "#b26", "idx": 7}, {"begin": 2939, "end": 2960, "target": "#b3", "idx": 8}, {"begin": 2990, "end": 3010, "target": "#b2", "idx": 9}, {"begin": 3305, "end": 3326, "target": "#b5", "idx": 10}, {"begin": 3400, "end": 3420, "target": "#b18", "idx": 11}, {"begin": 4559, "end": 4580, "target": "#b16", "idx": 12}, {"begin": 4581, "end": 4602, "target": "#b19", "idx": 13}, {"begin": 4603, "end": 4623, "target": "#b3", "idx": 14}, {"begin": 4624, "end": 4642, "target": "#b28", "idx": 15}, {"begin": 4643, "end": 4660, "target": "#b13", "idx": 16}, {"begin": 4661, "end": 4681, "target": "#b20", "idx": 17}, {"begin": 4964, "end": 4986, "target": "#b26", "idx": 18}, {"begin": 5430, "end": 5452, "target": "#b19", "idx": 19}, {"begin": 5866, "end": 5887, "target": "#b3", "idx": 20}, {"begin": 6448, "end": 6465, "target": "#b14", "idx": 21}, {"begin": 6718, "end": 6736, "target": "#b22", "idx": 22}, {"begin": 7138, "end": 7159, "target": "#b8", "idx": 23}, {"begin": 8000, "end": 8021, "target": "#b3", "idx": 24}, {"begin": 8034, "end": 8052, "target": "#b13", "idx": 25}, {"begin": 8100, "end": 8122, "target": "#b26", "idx": 26}, {"begin": 8995, "end": 9012, "target": "#b27", "idx": 27}, {"begin": 9776, "end": 9796, "target": "#b5", "idx": 28}, {"begin": 10650, "end": 10671, "target": "#b3", "idx": 29}, {"begin": 10672, "end": 10683, "target": "#b13", "idx": 30}, {"begin": 10703, "end": 10720, "target": "#b22", "idx": 31}, {"begin": 11404, "end": 11424, "target": "#b3", "idx": 32}, {"begin": 12104, "end": 12124, "target": "#b2", "idx": 33}, {"begin": 13077, "end": 13097, "target": "#b2", "idx": 34}, {"begin": 13587, "end": 13603, "target": "#b7", "idx": 35}, {"begin": 15507, "end": 15528, "target": "#b5", "idx": 36}, {"begin": 16277, "end": 16297, "target": "#b5", "idx": 37}, {"begin": 16339, "end": 16356, "target": "#b4", "idx": 38}, {"begin": 16357, "end": 16376, "target": "#b15", "idx": 39}, {"begin": 16481, "end": 16492, "target": "#b9", "idx": 40}, {"begin": 16543, "end": 16561, "target": "#b1", "idx": 41}, {"begin": 16588, "end": 16610, "target": "#b26", "idx": 42}, {"begin": 17488, "end": 17510, "target": "#b17", "idx": 43}, {"begin": 17511, "end": 17531, "target": "#b25", "idx": 44}, {"begin": 18020, "end": 18042, "target": "#b17", "idx": 45}, {"begin": 18172, "end": 18193, "target": "#b25", "idx": 46}, {"begin": 20963, "end": 20983, "target": "#b11", "idx": 47}, {"begin": 21368, "end": 21387, "target": "#b12", "idx": 48}, {"begin": 21719, "end": 21743, "target": "#b23", "idx": 49}, {"begin": 21761, "end": 21783, "target": "#b26", "idx": 50}, {"begin": 22349, "end": 22368, "target": "#b25", "idx": 51}, {"begin": 27852, "end": 27872, "target": "#b5", "idx": 52}], "ReferenceToFootnote": [{"begin": 9978, "end": 9979, "target": "#foot_1", "idx": 0}, {"begin": 15529, "end": 15530, "target": "#foot_3", "idx": 1}, {"begin": 16015, "end": 16016, "target": "#foot_4", "idx": 2}, {"begin": 17105, "end": 17106, "target": "#foot_5", "idx": 3}], "SectionFootnote": [{"begin": 27658, "end": 28546, "idx": 0}], "ReferenceString": [{"begin": 28563, "end": 28748, "id": "b0", "idx": 0}, {"begin": 28750, "end": 29007, "id": "b1", "idx": 1}, {"begin": 29011, "end": 29227, "id": "b2", "idx": 2}, {"begin": 29231, "end": 29419, "id": "b3", "idx": 3}, {"begin": 29423, "end": 29592, "id": "b4", "idx": 4}, {"begin": 29596, "end": 29796, "id": "b5", "idx": 5}, {"begin": 29800, "end": 30064, "id": "b6", "idx": 6}, {"begin": 30068, "end": 30142, "id": "b7", "idx": 7}, {"begin": 30146, "end": 30305, "id": "b8", "idx": 8}, {"begin": 30309, "end": 30417, "id": "b9", "idx": 9}, {"begin": 30421, "end": 30829, "id": "b10", "idx": 10}, {"begin": 30833, "end": 31115, "id": "b11", "idx": 11}, {"begin": 31119, "end": 31383, "id": "b12", "idx": 12}, {"begin": 31387, "end": 31622, "id": "b13", "idx": 13}, {"begin": 31626, "end": 31853, "id": "b14", "idx": 14}, {"begin": 31857, "end": 32014, "id": "b15", "idx": 15}, {"begin": 32018, "end": 32212, "id": "b16", "idx": 16}, {"begin": 32216, "end": 32410, "id": "b17", "idx": 17}, {"begin": 32414, "end": 32537, "id": "b18", "idx": 18}, {"begin": 32541, "end": 32802, "id": "b19", "idx": 19}, {"begin": 32806, "end": 33054, "id": "b20", "idx": 20}, {"begin": 33058, "end": 33215, "id": "b21", "idx": 21}, {"begin": 33219, "end": 33408, "id": "b22", "idx": 22}, {"begin": 33412, "end": 33588, "id": "b23", "idx": 23}, {"begin": 33592, "end": 33778, "id": "b24", "idx": 24}, {"begin": 33782, "end": 33939, "id": "b25", "idx": 25}, {"begin": 33943, "end": 34173, "id": "b26", "idx": 26}, {"begin": 34177, "end": 34462, "id": "b27", "idx": 27}, {"begin": 34466, "end": 34674, "id": "b28", "idx": 28}], "ReferenceToTable": [{"begin": 9975, "end": 9976, "idx": 0}, {"begin": 13988, "end": 13989, "idx": 1}, {"begin": 16168, "end": 16169, "target": "#tab_1", "idx": 2}, {"begin": 16667, "end": 16668, "target": "#tab_1", "idx": 3}, {"begin": 19830, "end": 19831, "target": "#tab_3", "idx": 4}, {"begin": 19879, "end": 19880, "target": "#tab_3", "idx": 5}, {"begin": 22058, "end": 22059, "target": "#tab_5", "idx": 6}, {"begin": 24485, "end": 24486, "target": "#tab_8", "idx": 7}, {"begin": 26837, "end": 26838, "target": "#tab_9", "idx": 8}], "Footnote": [{"begin": 27669, "end": 27750, "id": "foot_0", "n": "1", "idx": 0}, {"begin": 27751, "end": 27934, "id": "foot_1", "n": "2", "idx": 1}, {"begin": 27935, "end": 28102, "id": "foot_2", "n": "3", "idx": 2}, {"begin": 28103, "end": 28161, "id": "foot_3", "n": "4", "idx": 3}, {"begin": 28162, "end": 28342, "id": "foot_4", "n": "5", "idx": 4}, {"begin": 28343, "end": 28452, "id": "foot_5", "n": "6", "idx": 5}, {"begin": 28453, "end": 28507, "id": "foot_6", "n": "8", "idx": 6}, {"begin": 28508, "end": 28546, "id": "foot_7", "n": "9", "idx": 7}], "Paragraph": [{"begin": 79, "end": 1304, "idx": 0}, {"begin": 1322, "end": 2163, "idx": 1}, {"begin": 2164, "end": 3130, "idx": 2}, {"begin": 3131, "end": 3694, "idx": 3}, {"begin": 3695, "end": 4166, "idx": 4}, {"begin": 4167, "end": 4255, "idx": 5}, {"begin": 4256, "end": 4362, "idx": 6}, {"begin": 4363, "end": 4489, "idx": 7}, {"begin": 4504, "end": 6091, "idx": 8}, {"begin": 6128, "end": 7698, "idx": 9}, {"begin": 7711, "end": 7960, "idx": 10}, {"begin": 7985, "end": 8359, "idx": 11}, {"begin": 8394, "end": 8513, "idx": 12}, {"begin": 8578, "end": 8672, "idx": 13}, {"begin": 8673, "end": 9064, "idx": 14}, {"begin": 9065, "end": 9276, "idx": 15}, {"begin": 9300, "end": 9526, "idx": 16}, {"begin": 9527, "end": 10462, "idx": 17}, {"begin": 10490, "end": 11024, "idx": 18}, {"begin": 11048, "end": 11466, "idx": 19}, {"begin": 11645, "end": 11822, "idx": 20}, {"begin": 11887, "end": 11931, "idx": 21}, {"begin": 11932, "end": 12497, "idx": 22}, {"begin": 12695, "end": 13321, "idx": 23}, {"begin": 13464, "end": 14175, "idx": 24}, {"begin": 14234, "end": 14698, "idx": 25}, {"begin": 14713, "end": 15279, "idx": 26}, {"begin": 15314, "end": 16142, "idx": 27}, {"begin": 16162, "end": 16625, "idx": 28}, {"begin": 16626, "end": 17107, "idx": 29}, {"begin": 17127, "end": 17407, "idx": 30}, {"begin": 17408, "end": 17894, "idx": 31}, {"begin": 17895, "end": 19832, "idx": 32}, {"begin": 19852, "end": 20507, "idx": 33}, {"begin": 20508, "end": 20833, "idx": 34}, {"begin": 20869, "end": 21555, "idx": 35}, {"begin": 21621, "end": 21832, "idx": 36}, {"begin": 21833, "end": 22783, "idx": 37}, {"begin": 22798, "end": 23580, "idx": 38}, {"begin": 23581, "end": 24061, "idx": 39}, {"begin": 24062, "end": 24354, "idx": 40}, {"begin": 24373, "end": 24487, "idx": 41}, {"begin": 24504, "end": 24822, "idx": 42}, {"begin": 24876, "end": 25122, "idx": 43}, {"begin": 25123, "end": 25265, "idx": 44}, {"begin": 25296, "end": 25666, "idx": 45}, {"begin": 25699, "end": 25863, "idx": 46}, {"begin": 25879, "end": 26593, "idx": 47}, {"begin": 26594, "end": 26746, "idx": 48}, {"begin": 26750, "end": 26809, "idx": 49}, {"begin": 26810, "end": 26920, "idx": 50}, {"begin": 26921, "end": 27171, "idx": 51}, {"begin": 27186, "end": 27318, "idx": 52}, {"begin": 27319, "end": 27491, "idx": 53}, {"begin": 27492, "end": 27656, "idx": 54}], "SectionHeader": [{"begin": 0, "end": 1304, "idx": 0}], "SectionReference": [{"begin": 28548, "end": 34676, "idx": 0}], "Sentence": [{"begin": 79, "end": 184, "idx": 0}, {"begin": 185, "end": 349, "idx": 1}, {"begin": 350, "end": 596, "idx": 2}, {"begin": 597, "end": 788, "idx": 3}, {"begin": 789, "end": 868, "idx": 4}, {"begin": 869, "end": 1005, "idx": 5}, {"begin": 1006, "end": 1208, "idx": 6}, {"begin": 1209, "end": 1304, "idx": 7}, {"begin": 1322, "end": 1600, "idx": 8}, {"begin": 1601, "end": 1855, "idx": 9}, {"begin": 1856, "end": 2163, "idx": 10}, {"begin": 2164, "end": 2513, "idx": 11}, {"begin": 2514, "end": 2570, "idx": 12}, {"begin": 2571, "end": 2602, "idx": 13}, {"begin": 2603, "end": 2734, "idx": 14}, {"begin": 2735, "end": 3130, "idx": 15}, {"begin": 3131, "end": 3327, "idx": 16}, {"begin": 3328, "end": 3568, "idx": 17}, {"begin": 3569, "end": 3694, "idx": 18}, {"begin": 3695, "end": 3804, "idx": 19}, {"begin": 3805, "end": 4012, "idx": 20}, {"begin": 4013, "end": 4119, "idx": 21}, {"begin": 4120, "end": 4166, "idx": 22}, {"begin": 4167, "end": 4255, "idx": 23}, {"begin": 4256, "end": 4362, "idx": 24}, {"begin": 4363, "end": 4489, "idx": 25}, {"begin": 4504, "end": 4774, "idx": 26}, {"begin": 4775, "end": 4892, "idx": 27}, {"begin": 4893, "end": 5028, "idx": 28}, {"begin": 5029, "end": 5189, "idx": 29}, {"begin": 5190, "end": 5338, "idx": 30}, {"begin": 5339, "end": 5409, "idx": 31}, {"begin": 5410, "end": 5595, "idx": 32}, {"begin": 5596, "end": 5796, "idx": 33}, {"begin": 5797, "end": 5992, "idx": 34}, {"begin": 5993, "end": 6091, "idx": 35}, {"begin": 6128, "end": 6313, "idx": 36}, {"begin": 6314, "end": 6426, "idx": 37}, {"begin": 6427, "end": 6696, "idx": 38}, {"begin": 6697, "end": 6826, "idx": 39}, {"begin": 6827, "end": 6916, "idx": 40}, {"begin": 6917, "end": 7119, "idx": 41}, {"begin": 7120, "end": 7356, "idx": 42}, {"begin": 7357, "end": 7698, "idx": 43}, {"begin": 7711, "end": 7960, "idx": 44}, {"begin": 7985, "end": 8161, "idx": 45}, {"begin": 8162, "end": 8231, "idx": 46}, {"begin": 8232, "end": 8313, "idx": 47}, {"begin": 8314, "end": 8359, "idx": 48}, {"begin": 8394, "end": 8513, "idx": 49}, {"begin": 8578, "end": 8672, "idx": 50}, {"begin": 8673, "end": 8848, "idx": 51}, {"begin": 8849, "end": 9013, "idx": 52}, {"begin": 9014, "end": 9064, "idx": 53}, {"begin": 9065, "end": 9276, "idx": 54}, {"begin": 9300, "end": 9526, "idx": 55}, {"begin": 9527, "end": 9719, "idx": 56}, {"begin": 9720, "end": 9940, "idx": 57}, {"begin": 9941, "end": 9979, "idx": 58}, {"begin": 9980, "end": 10111, "idx": 59}, {"begin": 10112, "end": 10415, "idx": 60}, {"begin": 10416, "end": 10462, "idx": 61}, {"begin": 10490, "end": 10553, "idx": 62}, {"begin": 10554, "end": 10721, "idx": 63}, {"begin": 10722, "end": 10787, "idx": 64}, {"begin": 10788, "end": 10948, "idx": 65}, {"begin": 10949, "end": 11024, "idx": 66}, {"begin": 11048, "end": 11294, "idx": 67}, {"begin": 11295, "end": 11393, "idx": 68}, {"begin": 11394, "end": 11466, "idx": 69}, {"begin": 11645, "end": 11822, "idx": 70}, {"begin": 11887, "end": 11931, "idx": 71}, {"begin": 11932, "end": 11977, "idx": 72}, {"begin": 11978, "end": 12026, "idx": 73}, {"begin": 12027, "end": 12085, "idx": 74}, {"begin": 12086, "end": 12213, "idx": 75}, {"begin": 12214, "end": 12315, "idx": 76}, {"begin": 12316, "end": 12497, "idx": 77}, {"begin": 12695, "end": 12821, "idx": 78}, {"begin": 12822, "end": 13098, "idx": 79}, {"begin": 13099, "end": 13321, "idx": 80}, {"begin": 13464, "end": 13522, "idx": 81}, {"begin": 13523, "end": 13728, "idx": 82}, {"begin": 13729, "end": 13895, "idx": 83}, {"begin": 13896, "end": 13926, "idx": 84}, {"begin": 13927, "end": 14064, "idx": 85}, {"begin": 14065, "end": 14134, "idx": 86}, {"begin": 14135, "end": 14175, "idx": 87}, {"begin": 14234, "end": 14303, "idx": 88}, {"begin": 14304, "end": 14653, "idx": 89}, {"begin": 14654, "end": 14698, "idx": 90}, {"begin": 14713, "end": 14798, "idx": 91}, {"begin": 14799, "end": 14936, "idx": 92}, {"begin": 14937, "end": 15081, "idx": 93}, {"begin": 15082, "end": 15279, "idx": 94}, {"begin": 15314, "end": 15455, "idx": 95}, {"begin": 15456, "end": 15531, "idx": 96}, {"begin": 15532, "end": 15692, "idx": 97}, {"begin": 15693, "end": 15786, "idx": 98}, {"begin": 15787, "end": 15946, "idx": 99}, {"begin": 15947, "end": 16017, "idx": 100}, {"begin": 16018, "end": 16142, "idx": 101}, {"begin": 16162, "end": 16240, "idx": 102}, {"begin": 16241, "end": 16377, "idx": 103}, {"begin": 16378, "end": 16414, "idx": 104}, {"begin": 16415, "end": 16625, "idx": 105}, {"begin": 16626, "end": 16669, "idx": 106}, {"begin": 16670, "end": 16751, "idx": 107}, {"begin": 16752, "end": 16851, "idx": 108}, {"begin": 16852, "end": 16962, "idx": 109}, {"begin": 16963, "end": 17028, "idx": 110}, {"begin": 17029, "end": 17107, "idx": 111}, {"begin": 17127, "end": 17283, "idx": 112}, {"begin": 17284, "end": 17407, "idx": 113}, {"begin": 17408, "end": 17561, "idx": 114}, {"begin": 17562, "end": 17691, "idx": 115}, {"begin": 17692, "end": 17894, "idx": 116}, {"begin": 17895, "end": 18194, "idx": 117}, {"begin": 18195, "end": 18447, "idx": 118}, {"begin": 18448, "end": 18515, "idx": 119}, {"begin": 18516, "end": 18707, "idx": 120}, {"begin": 18708, "end": 18953, "idx": 121}, {"begin": 18954, "end": 19053, "idx": 122}, {"begin": 19054, "end": 19153, "idx": 123}, {"begin": 19154, "end": 19216, "idx": 124}, {"begin": 19217, "end": 19347, "idx": 125}, {"begin": 19348, "end": 19486, "idx": 126}, {"begin": 19487, "end": 19643, "idx": 127}, {"begin": 19644, "end": 19775, "idx": 128}, {"begin": 19776, "end": 19832, "idx": 129}, {"begin": 19852, "end": 19881, "idx": 130}, {"begin": 19882, "end": 20017, "idx": 131}, {"begin": 20018, "end": 20146, "idx": 132}, {"begin": 20147, "end": 20226, "idx": 133}, {"begin": 20227, "end": 20335, "idx": 134}, {"begin": 20336, "end": 20477, "idx": 135}, {"begin": 20478, "end": 20507, "idx": 136}, {"begin": 20508, "end": 20554, "idx": 137}, {"begin": 20555, "end": 20660, "idx": 138}, {"begin": 20661, "end": 20714, "idx": 139}, {"begin": 20715, "end": 20833, "idx": 140}, {"begin": 20869, "end": 21071, "idx": 141}, {"begin": 21072, "end": 21228, "idx": 142}, {"begin": 21229, "end": 21390, "idx": 143}, {"begin": 21391, "end": 21456, "idx": 144}, {"begin": 21457, "end": 21530, "idx": 145}, {"begin": 21531, "end": 21555, "idx": 146}, {"begin": 21621, "end": 21832, "idx": 147}, {"begin": 21833, "end": 21998, "idx": 148}, {"begin": 21999, "end": 22051, "idx": 149}, {"begin": 22052, "end": 22146, "idx": 150}, {"begin": 22147, "end": 22369, "idx": 151}, {"begin": 22370, "end": 22530, "idx": 152}, {"begin": 22531, "end": 22708, "idx": 153}, {"begin": 22709, "end": 22783, "idx": 154}, {"begin": 22798, "end": 22960, "idx": 155}, {"begin": 22961, "end": 23182, "idx": 156}, {"begin": 23183, "end": 23324, "idx": 157}, {"begin": 23325, "end": 23443, "idx": 158}, {"begin": 23444, "end": 23580, "idx": 159}, {"begin": 23581, "end": 23652, "idx": 160}, {"begin": 23653, "end": 23806, "idx": 161}, {"begin": 23807, "end": 23889, "idx": 162}, {"begin": 23890, "end": 24061, "idx": 163}, {"begin": 24062, "end": 24156, "idx": 164}, {"begin": 24157, "end": 24263, "idx": 165}, {"begin": 24264, "end": 24354, "idx": 166}, {"begin": 24373, "end": 24487, "idx": 167}, {"begin": 24504, "end": 24652, "idx": 168}, {"begin": 24653, "end": 24721, "idx": 169}, {"begin": 24722, "end": 24822, "idx": 170}, {"begin": 24876, "end": 24994, "idx": 171}, {"begin": 24995, "end": 25068, "idx": 172}, {"begin": 25069, "end": 25122, "idx": 173}, {"begin": 25123, "end": 25190, "idx": 174}, {"begin": 25191, "end": 25265, "idx": 175}, {"begin": 25296, "end": 25437, "idx": 176}, {"begin": 25438, "end": 25584, "idx": 177}, {"begin": 25585, "end": 25666, "idx": 178}, {"begin": 25699, "end": 25863, "idx": 179}, {"begin": 25879, "end": 26006, "idx": 180}, {"begin": 26007, "end": 26085, "idx": 181}, {"begin": 26086, "end": 26264, "idx": 182}, {"begin": 26265, "end": 26357, "idx": 183}, {"begin": 26358, "end": 26491, "idx": 184}, {"begin": 26492, "end": 26593, "idx": 185}, {"begin": 26594, "end": 26746, "idx": 186}, {"begin": 26750, "end": 26809, "idx": 187}, {"begin": 26810, "end": 26839, "idx": 188}, {"begin": 26840, "end": 26920, "idx": 189}, {"begin": 26921, "end": 27017, "idx": 190}, {"begin": 27018, "end": 27076, "idx": 191}, {"begin": 27077, "end": 27171, "idx": 192}, {"begin": 27186, "end": 27318, "idx": 193}, {"begin": 27319, "end": 27425, "idx": 194}, {"begin": 27426, "end": 27491, "idx": 195}, {"begin": 27492, "end": 27596, "idx": 196}, {"begin": 27597, "end": 27656, "idx": 197}], "ReferenceToFigure": [{"begin": 10458, "end": 10461, "target": "#fig_0", "idx": 0}, {"begin": 20668, "end": 20669, "idx": 1}, {"begin": 25711, "end": 25712, "target": "#fig_4", "idx": 2}, {"begin": 27444, "end": 27445, "target": "#fig_5", "idx": 3}, {"begin": 27499, "end": 27500, "target": "#fig_6", "idx": 4}, {"begin": 27512, "end": 27513, "target": "#fig_7", "idx": 5}], "Div": [{"begin": 79, "end": 1304, "idx": 0}, {"begin": 1307, "end": 4489, "idx": 1}, {"begin": 4491, "end": 6091, "idx": 2}, {"begin": 6093, "end": 7698, "idx": 3}, {"begin": 7700, "end": 7960, "idx": 4}, {"begin": 7962, "end": 8359, "idx": 5}, {"begin": 8361, "end": 9276, "idx": 6}, {"begin": 9278, "end": 10462, "idx": 7}, {"begin": 10464, "end": 11024, "idx": 8}, {"begin": 11026, "end": 14207, "idx": 9}, {"begin": 14209, "end": 14698, "idx": 10}, {"begin": 14700, "end": 15279, "idx": 11}, {"begin": 15281, "end": 16142, "idx": 12}, {"begin": 16144, "end": 17107, "idx": 13}, {"begin": 17109, "end": 19832, "idx": 14}, {"begin": 19834, "end": 20833, "idx": 15}, {"begin": 20835, "end": 21601, "idx": 16}, {"begin": 21603, "end": 22783, "idx": 17}, {"begin": 22785, "end": 24354, "idx": 18}, {"begin": 24356, "end": 24487, "idx": 19}, {"begin": 24489, "end": 24822, "idx": 20}, {"begin": 24824, "end": 25265, "idx": 21}, {"begin": 25267, "end": 25666, "idx": 22}, {"begin": 25668, "end": 25863, "idx": 23}, {"begin": 25865, "end": 26746, "idx": 24}, {"begin": 26748, "end": 27171, "idx": 25}, {"begin": 27173, "end": 27656, "idx": 26}], "SectionMain": [{"begin": 1304, "end": 27656, "idx": 0}]}}