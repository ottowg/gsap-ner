{"text": "Design of Capacity-Approaching Low-Density Parity-Check Codes using Recurrent Neural Networks\n\nAbstract:\nIn this paper, we model Density Evolution (DE) using Recurrent Neural Networks (RNNs) with the aim of designing capacity-approaching Irregular Low-Density Parity-Check (LDPC) codes for binary erasure channels. In particular, we present a method for determining the coefficients of the degree distributions, characterizing the structure of an LDPC code. We refer to our RNN architecture as Neural Density Evolution (NDE) and determine the weights of the RNN that correspond to optimal designs by minimizing a loss function that enforces the properties of asymptotically optimal design, as well as the desired structural characteristics of the code. This renders the LDPC design process highly configurable, as constraints can be added to meet applications' requirements by means of modifying the loss function.\nIn order to train the RNN, we generate data corresponding to the expected channel noise. We analyze the complexity and optimality of NDE theoretically, and compare it with traditional design methods that employ differential evolution. Simulations illustrate that NDE improves upon differential evolution both in terms of asymptotic performance and complexity. Although we focus on asymptotic settings, we evaluate designs found by NDE for finite codeword lengths and observe that performance remains satisfactory across a variety of channels.\nI. INTRODUCTION\nThe quality of communication over erroneous channels is degraded due to the presence of noise. It is known that, in order to ensure an arbitrarily small probability of error at the receiver, the rate of communication should not exceed the channel capacity, dictated by the level and nature of noise [1]. Channel coding [2]-[4] aims at adding redundancy to the communicated E. Nisioti and N. Thomos are with the\n\nMain:\n\n\n\nformance to find well-performing codes.v 1 v 2 v 3 v 4 v 5 v 6 c 1 c 2 c 3\nFig. 2. The bipartite graph used to describe an LDPC code: the lower (upper) row consists of variable (check)\nnodes. An edge indicates that a codeword bit participates in a parity-check constraint.\nmessages so that errors, introduced during transmission over a noisy channel, can be corrected at the receiver. Low-density parity-check (LDPC) codes [5] are a prominent family of channel codes, the interest in which has been recently reignited due to the need of 5G for low complexity coding schemes that can recover messages at rates close to the channel capacity [6]. In order to find well-performing channel codes for a variety of code-rates and message lengths, we are in need of efficient, effective and configurable design methods for this family of channel codes.\nWithout loss of generality, we assume messages generated by independent and identically distributed sources [1]. Prior to transmission, source information bits are partitioned into nonoverlapping message blocks of k bits, and each block s is encoded by means of channel coding to form a codeword c of n bits, with n >= k. The added bits aim at protecting the source message against errors introduced due to channel noise. Source messages can be recovered at the receiver's end by means of channel decoding, which maps the received codewords (error-contaminated) \u0109\nto an estimation of the source message s using, among other techniques, maximum likelihood estimation [7]. Channel codes aim at recovering the original message at the decoder, i.e. s = s, with high probability, while at the same time adding as little redundancy as possible. This overall communication flow chart is presented in Fig. 1.\nLow-density parity-check codes [5] can be described in two ways: (i) using the parity-check matrix H, which determines the set of \"admissible\" codewords of a code, denoted as C(n, k).\nIn particular, a codeword is admissible, if it belongs to the set of right null vectors of H, i.e.\nx \u2208 C(n, k) iff Hc T = 0 T . The parity-check matrix is related to the generator matrix G, used to encode an information block s in order to generate a codeword x transmitted over the channel, with the formula: GH T = 0 T ; (ii) the Tanner graph, a bipartite graph of the form presented in Fig. 2, where each variable node is associated with a codeword bit and check nodes represent parity-check constraints. In the example presented in Fig. 2, codewords respect the following parity-check constraints: c 1 \u2295 c 2 \u2295 c 4 = 0, c 3 \u2295 c 4 \u2295 c 6 = 0, c 1 \u2295 4 \u2295c 5 = 0, where \u2295 denotes the XOR function The relationship between the two representations is straightforward: variable nodes correspond to columns of H and check nodes to rows; an edge exists between two nodes if the corresponding entry in H is non-zero. The structure of LDPC codes is traditionally derived by sampling the degree distributions \u03bb(x) and \u03c1(x) in order to determine the degrees 1 of the variable and check nodes respectively. As H is typically sparse, both encoding and decoding have low time complexity increasing linearly with the codeword length.\nDensity Evolution (DE) is a recursive update formula that models the evolution of messages exchanged in a Belief propagation (BP) decoder, and is traditionally employed for the design of LDPC codes [8]. DE assumes that codewords have infinite length, which significantly simplifies the analysis, by converting the Tanner graph to a tree, where messages evolve independently from each other. In this work, we assume that codewords are transmitted over the binary erasure channel (BEC), introduced in [9], in alignment with the literature related to the analysis of DE [8], [10]. In the BEC, the probability of decoding failure at iteration t + 1 under DE is given by x t+1 ( ) = \u03bb(1 \u2212 (\u03c1(1 \u2212 x t ))), where x t is the probability of failure at iteration t, \u03c1(x) and \u03bb(x) are the degree distributions characterizing the considered code, and is the probability of erasure. The code design process is a two-step iterative procedure, illustrated in Fig. 4. First, the space of degree distributions is explored to find degree distribution pairs for evaluation, a highly non-linear constraint satisfaction problem, traditionally solved using differential evolution [8]. Second, the selected pairs are evaluated using DE or BP by calculating BP , the maximum erasure probability that can be tolerated by the code.\nBy viewing code design as a non-linear optimization problem, we can alternatively leverage the framework of artificial neural networks (ANNs). Recurrent neural networks (RNNs) are ANNs employed when data exhibit time dependencies, and their dynamic behavior can be described by differential equations [11] - [13]. From this perspective, learning can be seen as an attempt to make the internal state of the network converge to the fixed point indicated by the labels provided in the training data [14]. In this paper, we model the code design process as a supervised learning problem by mapping the recursive update equation of DE to an RNN architecture, that we refer to as Neural Density Evolution (NDE). This RNN modeling constitutes an elegant way to incorporate \u03bb(x) and \u03c1(x) into the design process simultaneously, as degree distribution coefficients are mapped to the weights of two consecutive layers of the neural network. The assumption of infinite codeword lengths, made by DE analysis, is also required by the proposed solution. Due to this assumption, we can also leverage the concentration theorem [15], according to which the performance of the various realizations of the graph concentrates around their expected value. We, therefore, construct the parity-check matrix randomly by sampling the degree distributions and evaluate the designs based on ensemble averages.\nIn order to find the weights of NDE that lead to capacity-approaching designs, we employ gradient-based optimizers [16]. Although gradient-based search was employed in [8] on the evaluation of (\u03bb(x), \u03c1(x)) pairs using a BP decoder and heuristic search was coupled with DE, to the best of our knowledge, this is the first method that combines gradient-based optimization and DE analysis. Up to now, the best-performing designs in the literature have been found using differential evolution, a global optimization technique [17]. However, our results prove that local optimization can lead to better designs, if appropriate measures are taken to avoid convergence to local optima of bad quality. This improvement over [8] can be attributed to the prohibitive complexity of global optimizers, which in practical settings (i.e. large codeword lengths and degree distribution degrees) fail to approach the theoretically optimal solution. In Section V, we comment on the complexity of NDE and, in Section VII-E, we perform extensive simulations to compare the efficiency of NDE, in terms of time complexity, with that of code design using differential evolution.\nFurthermore, we define a multi-objective loss function for NDE which reflects the requirements of optimal code design. In particular, we design loss terms to ensure that: (i) the learned weights correspond to coefficients of valid degree distributions, (ii) the learned weights lead to the desired code-rate and density of the parity-check matrix H, and, (iii) the probability of decoding failure is zero. Our approach belongs to the realm of soft constraint optimization, while previous approaches that ensured valid degree distributions by projecting solutions on constraint-induced hyperplanes [8] employ hard constraints. Although soft constraints have been found to require special attention when balancing loss terms, they are far more computationally attractive than imposing hard constraints on the weights of the network [18]. Simultaneously, our definition of the loss function ensures high configurability of NDE, the behavior of which can be further customized by introducing additional loss terms.\nIn order to train and evaluate NDE, we generate artificial data based on the target channel model and capacity. We, then, investigate the optimality of our solution, where we analyze DE as a dynamical system and comment on the ability of NDE to find capacity-achieving and capacityapproaching designs. To this aim, we leverage known results on the optimality of irregular LDPC codes, as well as properties of RNNs and gradient-descent optimizers [8].\nWe experimentally confirm that NDE can be used to design capacity approaching codes for a variety of configurations, i.e. various code-rates and maximum degrees of \u03bb(x) and \u03c1(x).\nWe also examine the properties of the learned DE and draw meaningful conclusions on the effect that the number of decoding iterations has on the quality of the design. As part of our experimental analysis, we employ two types of graphs for describing the dynamic behavior of NDE: (i) bifurcation diagrams, commonly used to visualize the behavior of dynamical systems [11], [13]; (ii) a type of plot referred to as the graphical determination of threshold in [7].\nAlthough during optimization we assume infinite codeword lengths and transmission over the BEC, we evaluate our designed codes on the transmission of moderate codeword lengths over the channel with additive white Gaussian noise (AWGN) noise. Our simulations confirm that the generated codes remain well-performing, which is in accordance to what was observed in [8].\nIn the rest of the paper, we first present related works in Section II. Relevant theoretical background is provided in Section III. In Section IV, we present our main contribution, NDE, on the complexity of which we comment in Section V. We, then, proceed with an analysis of NDE's optimality in Section VI. Simulations for evaluating NDE in asymptotic and finite settings are presented in Section VII, and in Section VIII we conclude our work and comment on future directions.\n\nII. RELATED WORK\nIrregular LDPC codes [15] quickly acquired a prominent position in the family of channel codes due to their low complexity and their ability to transmit at rates close to capacity with low probability of error. In [8], DE was leveraged for the design of irregular LDPC codes. First, optimal values for the coefficients of \u03bb(x) were found using a simple local search algorithm, where only a few non-zero terms were proven adequate for achieving good performance. In addition, a derivative was formulated for hill-climbing algorithms and globally optimizing a linear interpolation of the loss function. The calculation of the latter required simulating the BP decoder and evaluating the bit-error-rate (BER) of the code during the design process. This differs from our approach, which, although also calculates derivatives as part of the back-propagation algorithm employed by the RNN, does not require information related to the simulated performance. Considering such information would be computationally expensive and would only ensure that the designed code will be optimal for a predefined code-length. The best-performing optimization technique in [8] was differential evolution, a global evolutionary optimizer often used for multivariate loss functions. The work in [8] offered important insights into the nature of code design as an optimization problem, as it was observed that searching over the parameter space often gets trapped at critical points that are almost fixed points. Despite being capable of finding the optimal solution, differential evolution was also studied in [17] as an optimizer for training ANNs and proved to be inferior, both in complexity and achieved performance.\nIn order to improve the performance of irregular LDPC codes under an asymptotic analysis, DE was extensively studied as a dynamical system in [8], [19]. These works contain a condition under which zero, the point representing a zero probability of decoding failure and, thus, corresponding to successful communication, is a stable fixed point of DE. It was also observed that zero is always a fixed point, but, for a specific degree distribution pair (\u03bb(x), \u03c1(x)), additional fixed points can come into existence. In [7], it was also observed that a capacity-achieving code has an infinite number of fixed points when operating at the Shannon capacity, as BP decoding comes to a halt for any initial condition. Above the Shannon capacity, the fixed point at zero is unstable, so the probability of decoding error converges to a high value, which lies close to the initial point of evaluation of DE [19].\nThe dynamic properties of RNNs early on attracted the interest of the research community, as their dynamic behavior significantly differs from feedforward neural networks. In [12], the long-standing observation that RNNs cannot learn long-term dependencies was attributed to the fact that these required that the gradient, whose calculation is necessary for back-propagation, vanishes or explodes. In [13], a study of an RNN with a single neuron using the concept of bifurcation diagrams is presented.\nThe application of machine learning techniques in the area of channel codes has recently attracted significant interest. In contrast to our work, which concerns itself with the design of codes, the majority of recent contributions are concerned with decoding. In [20], an endto-end communication system was viewed as an autoencoder, thus allowing for the encoding and decoding process to be jointly optimized. In [21], deep learning was employed to perform joint source and channel coding, with raw signal values being directly mapped to complex-valued transmitted signals, and results confirmed the advantages of this design for image communication and its resilience to noise mismatch. In [22], channel decoding was viewed as a supervised classifier, employed to decode randomly constructed codes and polar codes, with the former failing to generalize to unseen codewords. This approach suffers from the curse of dimensionality, as the size of the data increases to prohibitive levels, even for deep learning solutions. Different from these works, which do not explicitly optimize the channel code but view it as an end-to-end system, we aim at leveraging properties of the code design process already established in the coding theory, such as the independence of the evolution of messages in a tree-structured Tanner graph and the concentration theorem. In [23], BP was mapped to a neural network and both a feedforward and a recurrent architecture was examined. The authors observed that the ability of correcting errors was improved, when compared to that of traditional BP, an observation attributed to the fact that learning led to finding values for the weights which obliterate short cycles, known for increasing the probability of BP failure. The neural network implementation of BP in [23] resembles to some extend ours, as both schemes implement a message-passing update mechanism. In particular, DE is equivalent to BP under the assumption of infinite codeword lengths. However, we should note that our work is concerned code design, while the ANN in [23] was used for decoding. In [24], the problem of error-correction code design was solved using both a reinforcement learning and a genetic programming solver and well-performing designs were found. However, these techniques required feedback from the decoder, which can be problematic if we consider the introduced delay, the increased time complexity of the design process and the probability of having erroneous feedback. Also, both solvers are not expected to adapt quickly to changing channel conditions, as they require extensive interaction to converge.\nJanuary 7, 2020 DRAFT\nThe classical definition of irregular LDPC codes has been extended in a variety of directions.\nIn particular, the idea of viewing a code as a combination of smaller is considered essential for ensuring low complexity and versatility in 5G New Radio [6]. We would like to note that our solution regards the code design problem and, hence, can be coupled with alternative definitions of LDPC codes. For example, NDE can be useful in improving the macroscopic statistical properties of LDPC codes in 5G New Radio, as these are predicted by DE, while its architecture can be extended to consider cascades of codes [15].\n\nIII. BACKGROUND\nIn this section, we provide some additional background on linear block codes and the design of irregular LDPC codes using DE.\n\nA. Linear block codes\nLet us assume an end-to-end communication system as the one illustrated in Fig. 1. Furthermore, let us consider that the source messages are binary vectors s= [s 1 , ...s k ], with s i \u2208 {0, 1}\nand that all mathematical operations take place in F 2 . A channel code C(n, k) is characterized by its code-rate R = k/n, which corresponds to the percentage of information bits k in a codeword of length n. Channel decoding can be performed by means of maximum likelihood estimation, where an estimate c of the original codeword c is calculated as:c = arg max c\u2208C(n,k) p \u0109|c (\u0109|c)\nRecall that C(n, k) is a set containing all admissible codewords and p \u0109|c (\u0109|c) represents the conditional probability of observing the codeword \u0109 (after transmission through the channel)\ngiven that the codeword c was transmitted. ( 1) is valid under the assumption that all codewords are equiprobable and is traditionally solved using BP.\n\nB. Designing irregular LDPC codes\nThe structure of an irregular LDPC code, as presented in Figs. 2 and 3, can be derived from the degree distributions, which have the following form:\u03bb(x) = \u03bbmax i=0 \u03bb i x i+1 \u03c1(x) = \u03c1max i=0 \u03c1 i x i+1\nwhere \u03bb max (\u03c1 max ) is the maximum allowed number of edges emanating from a variable (check)\nnode. An edge in the graph has a lower (upper) degree i (see Fig. 2), if it is connected to a lower (upper) node of degree i. The objective of code design is to determine the variables \u03bb i (\u03c1 i ). Polynomial distributions of the above form are valid degree distributions if they have non-negative coefficients and their sum is equal to 1. In addition, the degree distributions need to respect the rate constraints of the code, i.e. n \u2022 \u03bb = k \u2022 \u03c1, where \u03bb and \u03c1 denote the average degree of the distributions.\nOnce the degree distributions have been found, LDPC codes can be constructed by randomly sampling them. Through \u03bb(x) and \u03c1(x), a family of codes is determined, as there are multiple H matrices that meet the constraints. However, this does not affect the quality of the design under the assumption of infinite codeword lengths, due to the concentration theorem [15]. A trivial way to build the bipartite graph from \u03bb(x) and \u03c1(x) is to sample these distributions to determine the number of edges emanating from a variable (check) node, and then, randomly connect the edges. We also remove 4-cycles from H [25], which significantly improves the achieved BER, as has been reported in the related literature [26].\n\nC. Density Evolution\nAs we briefly discussed in Section I, DE has an iterative form, given in (3) for BEC. Let \u2208 [0, 1] denote the probability of a bit being erased during transmission due to channel noise.\nThe probability of decoding failure at the next decoding iteration under DE is given by:x t+1 ( ) = \u03bb(1 \u2212 \u03c1(1 \u2212 x t )),\nwhere x t denotes the probability of failure at iteration t. DE can be used to assess the design indicated by a (\u03bb(x), \u03c1(x)) pair without requiring to evaluate the performance of the channel code in a simulated channel. The evaluation begins by considering an initial point x 0 , which is typically set to , as this corresponds to the probability of failure prior to the beginning of decoding. Due to the assumption of infinite codeword lengths and i.i.d. source message bits, we only examine the evolution of the decoding for one variable node, and assume that the same occurs independently for the other nodes.\nIn Fig. 5, we illustrate how the probability of failure, x t , evolves with decoding iterations for a specific (\u03bb(x), \u03c1(x)) pair using this formula. We observe that x t approaches 0 within a small number of iterations, as the probability of erasure ( = 0.3) was lower than the code-rate (R = 0.5).\n\nIV. NEURAL DENSITY EVOLUTION\nIn this section, we describe Neural Density Evolution, our proposed solution for LDPC code design. First, we define the update formula of an RNN that mimics the dynamics of DE. Then, we map this formula to our RNN architecture and describe the data generation process. Finally, we define a loss function that guarantees the desired code characteristics and ensures capacityapproaching performance.\n\nA. Mapping DE to an RNN\nWe can view an RNN as a dynamical system, described by the following difference equation:x t = W rec \u03c3(x t\u22121 ) + W in u t + b\nwith W rec denoting the recurrent weight matrix, W in the input weight matrix, b a constant bias term and \u03c3(\u2022) representing the sigmoid activation function. An RNN accepts an input u t and is characterized by its state x t , updated at each learning iteration. We illustrate this behavior of an RNN in Fig. 6.\nAs our intention is that of modeling DE, we need to adjust the general RNN update equation, as expressed in ( 4), so that it agrees with the DE formula presented in (3). For this reason, we drop the terms related to the bias, replace the sigmoid activation function \u03c3(\u2022) with the identity function and substitute the input weight matrix with the identity matrix. In addition, we replace the addition between the first two terms in (4) with a multiplication. Thus, the difference equation of our RNN is:x t = W rec (x t\u22121 )u t\nThese transformations do not affect the ability of the RNN to find good solutions, as ANNs have been found well-performing for a variety of activation functions and architectures [27].\nAs is customary in the machine learning community, we refer to the elements in W rec as the parameters of the learning algorithm, while we use the term hyperparameters to describe the parameters of the learning algorithm that are set prior to training, such as the learning rate, number of epochs and length of the unfolded RNN.\n\nB. Defining the RNN architecture\nThe trainable weights of NDE correspond to the coefficients of the degree distributions, defined in (2). When compared to feed-forward architectures, an RNN bears the advantage that weights are shared among corresponding layers, which means that the learning algorithm needs to optimize a small number of parameters. The proposed RNN architecture is presented in Fig. 7, where the coefficients of \u03c1(x) have been mapped to the weights of the first layer of the RNN and the coefficients of \u03bb(x) to the weights of the second layer. We restrict the length of the unfolded RNN to a few layers, as this helps maintain low training complexity. As the length of the RNN coincides with the number of decoding iterations performed by BP, we expect that the performance of the design will not be affected, as, when BP converges, this usually occurs early in the decoding process [28].\n\nC. Generating training data\nIn order to train the RNN in a supervised manner, we need labeled data, of the form (features, class).\nAs we aim at designing channel codes for BEC, we present how we generate data for this type of channel. We define as features the inputs of DE, namely , which represents the probability of a bit erasure and x, the point of evaluation of DE. The class of our training data indicates the desired output of DE, which is 0, i.e., the fixed point that corresponds to the probability that the data has been recovered after decoding with no errors for < Sh , where Sh denotes the channel capacity, and a positive constant in the range ( Sh , 1) otherwise. As we observe in the bifurcation diagram presented in Fig. 12, this constant is very close to Sh . Note that, the analysis employed by DE is independent of the transmitted codeword [29], we therefore assume transmission of the all-zero codeword.(1 \u2212 x) 0 (1 \u2212 x) 1 (1 \u2212 x) 2 \u03c11 \u03c12 \u03c13 (1 \u2212 x) 1 (1 \u2212 x) 2 (1 \u2212 x) 3 (1 \u2212 x) 0 (1 \u2212 x) 4\nIn order to select an appropriate range of values for , we can consult the following Lemma [7] :\nLemma 1 (Monotonicity with respect to channel [7]). Let (\u03bb(x), \u03c1(x)) be a degree distribution pair and\u2208 [0, 1]. If x t ( ) t\u2192\u221e \u2212 \u2212\u2212 \u2192 0, then x t ( ) t\u2192\u221e \u2212 \u2212\u2212 \u2192 0 for all 0 \u2264 \u2264 .\nIt is, however, known that the performance of irregular LDPC codes is bounded away from capacity by a constant that depends on \u03c1. In particular, the analysis in [30] calculated this constantas \u03b4 min = (R \u03c1\u22121 (1 \u2212 R))/(1 + R \u03c1\u22121 (1 \u2212 R)).\nWe denote as BP max the noise value that corresponds to \u03b4 min , which represents the maximum achievable noise value below which the probability of error using a BP decoder approaches 0, and can be calculated as (1 \u2212 \u03b4 min \u2212 R)/(1 \u2212 \u03b4 min ). Thus, for our problem, BP max , and not Sh , is considered the optimal solution. Based on the preceding discussion, we can train the network to minimize BER for error probabilities close to BP max and expect BER to be zero for lower error probabilities. However, it is intuitive, and was confirmed by simulations, that creating data for lower erasure values can facilitate training. This idea was motivated by curriculum learning, a machine learning technique according to which an optimizer is presented with data of increasing difficulty in order to gradually manage to solve harder problems [31]. However, in order to describe valid degree distributions, the weights need to satisfy the following constraints:\u03bbmax i=0 \u03bb i = 1 and 0 \u2264 \u03bb i \u2264 1, \u2200i \u2208 [0, \u2022 \u2022 \u2022 , \u03bb max \u2212 1] \u03c1max i=0 \u03c1 i = 1 and 0 \u2264 \u03c1 i \u2264 1, \u2200i \u2208 [0, \u2022 \u2022 \u2022 , \u03c1 max \u2212 1]\nTo enforce the above constraints we can use weight clipping, a technique commonly employed to avoid saturation of the signals traversing the RNN. However, if we separately clip each weight by value, then we change the direction of the gradient calculated by gradient descent during training, which will most probably harm the quality of back-propagation [32]. Furthermore, applying weight clipping on the norm of the weight vector would not lead to coefficients that lie in the [0, 1] range. We therefore enforce the constraints in (6) indirectly, by employing additional loss terms that penalize weight vectors whose sum is not one and their individual elements are not in the [0, 1] range:\u2126 \u03bb = \u03bbmax i=0 min (\u03bb i , 0) + \u03bbmax i=0 max (\u03bb i , 1) + |1 \u2212 \u03bbmax i=0 \u03bb i | \u2126 \u03c1 = \u03c1max i=0 min (\u03c1 i , 0) + \u03c1max i=0 max (\u03c1 i , 1) + |1 \u2212 \u03c1max i=0 \u03c1 i |\nIn order to ensure that our design satisfies the rate constraint, i.e. \u03bb/\u03c1 = R, we calculate the desired \u03bb and \u03c1, based on the target codeword size and density d of H, and employ the following additional loss terms:\u2126\u03bb = \u03bbdesired \u2212 \u03bbmax i=2 (i \u2212 1)\u03bb i\n)\u2126 \u03c1 = \u03c1desired \u2212 \u03c1max i=2 (i \u2212 1)\u03c1 i ()\nwhere \u03bbdesired is calculated as d\u2022k and \u03c1desired as d\u2022n. The above terms facilitate the customization of NDE for varying structural requirements by setting \u03bbdesired and \u03bbdesired to their desired values.\nTo conclude, we formulate the total loss as calculated over all training examples D train :L(y, \u0177) = c MSE 1 n D train i=0 (y i \u2212 \u0177i ) 2 + c \u03bb \u2126 \u03bb + c \u03c1 \u2126 \u03c1 + c\u03bb\u2126\u03bb + c \u03c1\u2126 \u03c1\nwhere y i is the class, \u0177i is the prediction of the recurrent network and c MSE , c \u03bb , c \u03c1 , c\u03bb and c \u03c1 are constant parameters that control the gravity of the different loss terms, the values of which are tuned during simulations. In Section VI, we introduce an additional term in (10), based on our optimality analysis. The learning algorithm that we employ for minimizing the loss function is RMSprop [33], a state-of-the-art stochastic gradient descent algorithm that adapts the learning rate based on a moving window of gradient updates, and is therefore robust to large gradient and noise values.\nV. NDE COMPLEXITY n this section, we review the complexity of NDE as a design method for LDPC codes. Note that our introduction of NDE does not affect known results about the attractive complexity of this family of codes, related to encoding and decoding [7], as we preserve the sparsity of the code.\nAlthough the RNN can be unfolded in time to represent the multiple decoding iterations, it only contains two sets of distinct parameters, i.e. the coefficients of \u03c1(x) mapped to the weights of the first layers and the coefficients of \u03bb(x) mapped to the weights of the second layer. This facilitates optimization and suggests that the memory requirements of NDE are negligible. In addition, the convergence rate of RNNs to the fixed point indicated by the labels is geometric and depends on the size of the network, under the assumption that the fixed point is stable [34].\nThis suggests that well-performing designs can be found quickly. One pass of back-propagation on the RNN requires time that scales only linearly with the number of (unfolded) layers. We should also note that, in contrast to feedforward networks, this pass cannot be parallelized, due to the time dependency between consecutive layers. The time complexity of previous solutions that employed differential evolution for the design of degree distributions [8] was not investigated, as the focus was that of finding the most well-performing, yet still sub-optimal degree distributions, within the available time budget. In Section VII, we confirm that the time complexity of NDE is superior to differential evolution, and that it scales linearly with the network size.\n\nVI. NOTES ON OPTIMALITY\nIn this following, we describe the optimal solution of code design, analyze the ability of NDE to approach it, and further improve our definition of NDE in order to pursue capacity approaching designs. We characterize a design as capacity-achieving when it ensures successful decoding for noise values arbitrarily close to the performance bound of irregular LDPC codes, BP max [30]. This means that the concept of approaching capacity is not an abstract ability of a design to go sufficiently close to capacity, but follows a closed form expression that defines the optimal solution in relation to code-rate R and the average degree of \u03c1(x), \u03c1.\nBased on our definition of the loss function in Section IV-D, we know that, if the loss has been minimized, then the weights correspond to valid degree distributions and the probability of error is very close to zero. This means that DE has a fixed point at 0 for the optimized LDPC code design. However, the probability of failure after decoding can still be high, unless that fixed point is stable. It is known that the dynamic behavior of DE is characterized by the following stability condition, where we have replaced in (3) with x 0 for the sake of clarity.\nTheorem 1. (Stability condition for BEC [8]) Let us consider the DE update equationx t (x 0 ) = x 0 \u03bb(1 \u2212 \u03c1(1 \u2212 x t\u22121 ))\n.\nNecessity: If \u03bb (0)\u03c1 (1) > 1/x 0 , then there exists a constant \u03be = \u03be(\u03bb, \u03c1, x 0 ) such that for all t \u2208 N, x t (x 0 ) > \u03be(\u03bb, \u03c1, x 0 ) .\nSufficiency: If \u03bb (0)\u03c1 (1) < 1/x 0 , then there exists a constant \u03be = \u03be(\u03bb, \u03c1, x 0 ) such that if at some t x t (x 0 ) < \u03be we know that x t (x 0 ) converges to 0.\nUnder this stability condition and the observation that the output of NDE is sufficiently low, we know that the design can have zero probability of decoding failure when operating on channels whose erasure values have been used as training data. We take advantage of this condition and we modify the loss function, defined in (10), by introducing an additional error term for penalizing weight values that could lead to leaving the stability region of DE:L stab (y, \u0177) = L(y, \u0177) + c stab (\u03bb (0)\u03c1 (1) \u2212 1/ )\nwhere we leverage Theorem 1 to penalize weight values leading NDE outside the stability region and employ the constant c stab to control the effect of the new loss term.\nIn practice, the presence of local minima is not a deal breaker, as long as they are not bad, i.e. the design that they correspond to is sufficiently close to the Shannon capacity. Pursuing capacity-achieving designs faces two major restrictions: (i) increasing the maximum degrees of the employed degree distributions can help improve performance, but also means that the codeword length needs to be increased. If this does not happen, performance deviates from the asymptotic behavior predicted by DE and the code performs sub-optimally for finite codeword lengths; (ii) the closer to capacity the channel operates, the more decoding iterations are required.\nLarge codeword lengths are inappropriate for realistic decoder implementations, as they introduce delays and increase complexity. Thus, as we optimize a degree distribution pair (\u03bb(x), \u03c1(x))\nfor channel noise close to capacity and finite decoding iterations, optimization encounters a large number of local minima, an observation also made in [8]. Local minima are known to attract gradient-based optimizers, which has led to the development of gradient-based variants that employ additional information, such as momentum and second-derivatives, to escape or avoid attraction to bad local optima [16]. However, to the best of our knowledge, there exist no theoretical guarantees for avoiding them and the classical approach is that of performing numerous random initializations of the weight values, which can lead to reaching different local optima of the loss function surface. In the studied problem, we know that, as the weights approach a capacity-achieving design, the loss function surface is characterized by numerous local minima, each one leading to a design that operates very close to capacity. As we commented in Section I, these local optima are not \"bad\", in the sense that they lead to design with performance very close to the optimal one for practical implementations (finite codeword lengths and decoding iterations).\nIn our implementation, we focus on medium codeword lengths, in the range of (10 2, 10 5 ) and restrict the maximum degrees of the degree distributions \u03bb(x) and \u03c1(x) to a number significantly lower than the length of the codeword. In addition, we assume finite decoding iterations during the design process, with their number corresponding to the finite number of layers of the unfolded RNN.\nWe conclude our optimality analysis with a lemma on the sufficiency of simple neuronic units in our formulation of NDE. After the observation in [12] that RNNs made of simple cells cannot learn long-term dependencies, the machine learning community widely replaced simple cells with the more advanced long short-term memory (LSTM) models. One could, therefore, wonder whether the performance of NDE could be improved if we replace the simple neuronic models used in NDE with LSTM ones. This is not the case here, as DE is a recurrent equation that only exhibits dependencies one step in the past. Therefore, training is free from the common problems of exploding and vanishing gradients caused by long-term dependencies. This observation, which we summarize in Lemma 2, significantly contributes to avoiding the higher complexity of using more advanced models, which can lead to longer training times and difficulties in tuning.\nLemma 2. (Sufficiency of simple RNN cells) The employment of simple neuronic units of the form y = w \u2022 x, where y denotes the output of a neuron, x its input and w the weight of the input edge, is optimal for NDE.\n\nVII. SIMULATIONS\nIn this section, we evaluate NDE from various perspectives, primarily aiming at establishing the ability of NDE to find designs that approach capacity and surpass state-of-the-art LDPC code designs for a variety of code configurations in asymptotic settings. All simulations related to the design regard BEC. In addition, we present BER plots for finite codeword lengths over different channel types. Tables I and II summarize the values of parameters used in our simulations (unless different values are explicitly provided in the text) from the perspectives of the RNN and the LDPC code. We have used tensorflow [35] for training NDE were performed using, while some LDPC functionalities were implemented using pylpdc.\n\nA. Capacity approaching designs\nWe have simulated a variety of well-performing code designs from the related literature, including both regular [7] and irregular [2] LDPC codes and consolidated the results in Table III, where we also include our best-performing designs, i.e. NDE 1 . The majority of the codes presented in Table III exhibit a rate of approximately 0.5, as it is commonly studied in the literature. In addition, we also evaluate NDE on the design of codes with R \u2208 {0.33, 0.8}.\nTable III presents the results of these simulations, where we can see that NDE has approached capacity for a variety of configurations. For each design, we present the characteristics of the degree distributions and a number of metrics related to the performance of the code, where we define the gap \u03b4 as the difference Sh \u2212 BP and employ this metric to evaluate the code design in an asymptotic setting.\nFigs. 8 and 9 depict the graphical determination of the threshold of the code design for varying erasure values for the best-performing baseline method, IR 9 , and our solution NDE  (see Table III).\nrespectively. In this type of plot, BP is calculated as the maximum value of for which the graph of x t+1 \u2212x t , x t \u2208 [0, 1] does not exceed 0. When this graph tangentially touches 0 for a particular\nx t (critical point), then the decoder halts, as it cannot decrease the probability of decoding failure further. As was observed in [7], the more optimized the design is, the more critical points the graph will exhibit. This is due to the fact that, when a code is capacity-approaching, all points\nx \u2208 [0, BP ] are critical points. As can be seen in Fig. 9, in addition to exhibiting higher BP , our design exhibits a significantly larger number of critical points, so that seemingly all points in x \u2208 [0, 0.49] are fixed points.\n\nB. Insights into optimization\nIn this section, we shed light on the training procedure of NDE in order to get a better understanding of how the different hyperparameters of the learning algorithm and the RNN architecture affect the quality of the learned degree distributions. In Fig. 10, we present the evolution of the gap \u03b4 with training iterations, to examine the impact of the solver on the derived solution and convergence. Note that, we do not plot the values of the training loss, as it consists of many terms (see Eq. ( 10)) and exhibits variations that depend on the choice of the output threshold o low . We instead depict the gap \u03b4, as it is a clear indicator of the quality of the design. However, we would like to emphasize that the calculation of BP takes place only during the testing trials and not during the training ones, as this information is not part of the loss function. This helps us to avoid increasing the time complexity of training. If we focus on the best-performing model in Fig. 10, which employs RMSprop, we observe that \u03b4 is very high at the beginning of the training process, as the weights of NDE do not correspond to valid degree distributions (see conditions in ( 6)), but decreases significantly after 10 training iterations. Next, optimization focuses on improving the asymptotic performance of the design and, as we can observe in Fig. 10, the training procedure initially quickly approaches a small value, and then convergence to the final design is slow. After reaching the lowest value at 190 iterations, the distance starts increasing again. This can be attributed to the fact that the derivative values after 190 iterations are not high enough, due to the optimization algorithm having reached a local optimum. Finding a better solution is then hard, so the optimization algorithm starts moving towards worse solutions. As the learning rate has been decreased to low levels, the procedure cannot find the good solution again. Based on this observation, if we observe that testing performance deteriorates, we terminate training early.\nWe also present results that show the effect of different hyperparameterizations, in particular the choice of the optimizer and batch size. This analysis has the twofold objective of revealing how tuning was performed and also drawing insights into the nature of the code design problem.\nWe begin by examining the performance of different optimizers in Fig. 10. Note that our objective is not that of searching for the best-performing optimizer among all optimizers in the literature [16], as this would require exhaustive tuning of each one. Instead we focus on investigating whether classical gradient descent is capable of reaching good solutions or gets stuck at local optima. We experimented with RMSprop and Adam, two state-of-the-art gradient-based algorithms designed to effectively avoid local optima. In Fig. 10, we present the performance of these three optimizers. For the simple gradient-descent (SGD) optimizer, we have found the best value for the learning rate \u03b1 using grid-search in the interval (0.00001, 0.001). The same weight initialization and RNN architecture was used for all three optimizers. We kept the hyperparameters of Adam to their default values, as these were set by the authors in [36]. It is possible that tuning these parameters would give better results, but for these simulations we only tuned the learning rate and concluded that a value of 0.0001 performs optimally. As RMSprop exhibits good performance without requiring extensive tuning, we employ it in the remaining simulations.\nIn general, the batch size b has a significant effect on the performance of an optimizer, with smaller sizes favoring fast convergence and helping avoiding local minima, while larger sizes making optimization more robust to noise and efficient in parallelized implementations. When using batches in an online learning setting (instead of feeding the whole dataset at each learning  iteration), the number of training data does not matter, but convergence depends only on the number of updates (learning iterations per episode) and the richness of the training distribution [37]. As we are creating artificial data, the task can be seen as online learning. During tuning we aim at finding a well-performing combination of learning rate and batch size, with larger batch sizes resulting in fewer learning iterations per epoch. Fig. 11 shows the performance achieved using a random initialization of the RNN weights. We observe that the different batch sizes exhibit similar mean performance, with a size of 4 achieving the smallest gap, but variance differs significantly. In particular, the variances for a batch size of 8 and 16 are both very high. When b is set to 8, the optimizer in most cases satisfies the structural requirements but cannot optimize the threshold BP , while for b = 16 the structural requirements are often not satisfied due to selecting weights that do not correspond to valid degree distribution. These numerical results depend highly on the previously selected value of the learning rate.\n\nC. Dynamic analysis of degree distributions\nIn this section, we employ bifurcation diagrams to gain a better understanding of the dynamic behavior of our NDE-based LDPC code designs. In particular, Fig. 12 contains the bifurcation diagrams for our best-performing design NDE 1 and the baseline R 2 . We observe that, for NDE 1 , almost all points close to capacity can be fixed points when the initial point equals the Shannon capacity, whereas R 2 , which was chosen as the baseline method in Table III with the worst performance, does not exhibit this behavior. Furthermore, in Fig. 13, we present the convergence of DE to a fixed point for channels of increasing noise values. We observe that, when the experienced noise is low ( = 0.3), only a few iterations are required, while when we get closer to capacity ( = 0.47), we need to increase the number of decoding iterations from 100 to 1000 to ensure convergence to 0. Finally, for erasure values above the Shannon capacity ( = 0.7), DE converges very close to the initial point, which suggests that decoding has failed. This behavior has already been observed in Fig. 12, where all points above Sh are fixed points.\n\nD. Increasing the RNN size\nThe size of the RNN is determined by the number of neurons in each layer, as the number of layers is constrained to 2 by the definition of the architecture and the number of neurons in the first (second) layer agrees with the maximum degree of the degree distribution \u03bb(x) (\u03c1(x)).\nThus, when changing the size of the RNN we adjust the average degrees \u03bb and \u03c1 accordingly.\nIn Fig. 14, we present the achieved BP of NDE for varying average and maximum degrees. We, also, examine different combinations of maximum degrees and percentages of zero coefficients and perform random initializations of the RNN weights. When increasing \u03c1, we made two observations: (i) depending on the previous values, we will also need to increase the maximum degree of \u03c1(x), and perhaps also \u03bb(x). We usually keep these values as small as possible, to reduce the dimensionality of the problem and decrease computational time. As increasing the number of coefficients makes the search of the optimal coefficient values harder, we introduced weight masking in the training process. This technique was also followed in [8], as it was observed that very good distribution pairs exist with only a few non-zero terms. At the beginning of training, we randomly set to 0 a predefined percentage of the weights and also nullify the corresponding gradients during training; (ii) randomness decreases. This can be attributed to the fact that the number of optimization parameters increases and, therefore, the probability of starting the search from a \"bad\" random initialization is lower. In Fig. 14, we experiment with two types of RNN: (i) a fully-connected RNN where the number of trainable weights is equal to \u03bb max + \u03c1 max (30 for \u03c1 = 10 and 40 for \u03c1 = 15); (ii) an RNN that employs masking. In particular, 30% of the weights are randomly selected for masking and the total number of weights is 40 and 50 for \u03c1 = 10 and \u03c1 = 15, respectively. We observe that the performance achieved by a fully-connected network is in both cases worse, with performance significantly deteriorating as \u03c1 increases. This can be attributed to the large number of weights that make it hard for the optimizer to nullify all loss terms. When employing masking, performance slightly deteriorates and variance decreases when \u03c1 increases. This slight deterioration can be attributed to insufficient tuning of the optimizer.\n\nE. Efficiency\nIn this section, we evaluate the efficiency of NDE in terms of time complexity and compare it with that of differential evolution, the optimization method used by the baseline designs presented in Table III. Our implementation follows the description in [8], but we did not aim at replicating the presented results. Instead,we focus on measuring how the time complexity and convergence rate of differential evolution depends on the problem size, i.e. the number of coefficients. We have defined the loss function minimized by differential evolution in a similar spirit to our work, i.e. we optimize the decoding threshold BP and ensure that the found coefficients correspond to degree distributions. In particular, the loss function isL DiffE = | Sh \u2212 BP | + |R \u2212 (1 \u2212 \u03bb \u2212 \u03c1)| + |1 \u2212 \u03bbmax i=0 \u03bb i | + |1 \u2212 \u03c1max i=0 \u03c1 i |.\nIn Fig. 15, we present the evolution of the loss with the number of epochs for differential evolution, where we allowed a time budget of 250 epochs. We also experiment with different maximum degrees to examine the effect of the problem size on the quality and speed of differential evolution. As regards speed, we can see that, when the number of coefficients is small, differential evolution converges at around 50 epochs. Doubling the number of coefficients makes the problem harder, thus around 150 iterations are required to reach convergence. Finally, increasing the number of coefficients to 70 leads to designs that give non-zero loss. Note that, we do not compare these results with the ones presented in Fig. 10 related to the convergence speed of our method. This is because the definition and complexity of epochs in machine learning and evolutionary algorithms differs significantly. Instead, we compare the two approaches in Fig. 16 in terms of absolute running time and observe that the running times of both NDE and differential evolution increase in a linear way, but differential evolution requires around 5 times the time required by NDE for all problem sizes. We should note that, the reason why the time complexity of differential evolution stopped increasing for problems with more than 50 coefficients, is that it exceeded its time budget. As we can see in Fig. 15, this results in failing to reach zero loss for a problem of size 70.\n\nF. Bit-error-rate evaluation\nIn this section, we evaluate the performance of our design for finite codeword lengths in order to examine whether the superiority of NDE, already established in an asymptotic analysis, still remains. We construct our codes randomly, by sampling the produced degree distributions. As was described in [7], we calculate the number of edges as e = \u03bb = \u03c1 and assign a label to each edge from the set S 1 = {1, 2, \u2022 \u2022 \u2022 , e}. We define e sockets both for variable nodes check nodes, where each variable (check) node has a number of sockets chosen by sampling \u03bb(x)(\u03c1(x)). We, then, take a random permutation of S 1 , which we denote as S 2 = {\u03c0(1), \u03c0(2), \u2022 \u2022 \u2022 , \u03c0(e)}, where \u03c0(\u2022) indicates a random permutation of a label. Finally, we connect each edge from set S 1 to the corresponding element in S 2 and remove all 4-cycles. Although our NDE formulation concerns the BEC channel, we anticipate, based on empirical observations in [8], that our designs will perform well for a variety of channels. We therefore evaluate the performance of NDE 1 in the BEC and the AWGN channel and compare it with the performance achieved by IR 9 , the best-performing baseline method. Results are shown in Figs. 17 and 18. As we anticipated, the performance of the two designs does not differ significantly.\nIn Fig. 17, we observe that for erasure values close to 0.5, which corresponds to the Shannon capacity of this code, BER remains close to 0.5. As the channel becomes less erroneous, BER improves for both designs. In Fig. 18, we observe that performance improves drastically for large codewords (n = 2048) after 1 dB for both designs. In general, we can conclude that our design is well-performing across all channels under consideration and that shorter codewords exhibit worse performance than longer ones, which is aligned to what has been observed in the literature.\n\nVIII. CONCLUSIONS AND FUTURE WORK\nIn this work, we introduced neural density evolution, which models density evolution in the binary erasure channel as a recurrent neural network, and employed it for the design of irregular LDPC codes. Our simulations indicate that our designs achieve, and in some cases exceed, the performance of state-of-the-art designs in asymptotic settings and are well-performing for a variety of codeword lengths and channels. In addition, we have confirmed that NDE exhibits lower complexity than its counterparts while it avoids bad designs. Moreover, our loss function allows for the design of codes with variable rates, and can be further customized based on the code's structural requirements. We believe that our methodology can bring further benefits for channel coding, when combined with a neural network architecture that models DE for arbitrary channels. This tool could then offer capacity-approaching designs without requiring a model of the channel, but solely based on training data consisting of the original messages and the messages after transmission through a channel. Our approach can be beneficial for other coding schemes, such as cascades of codes and 5G New Radio codes, as it can render the design of these types of irregular LDPC codes efficient and customizable.\n\nFootnotes:\nJanuary 7, 2020 DRAFT\n1: The degree of a node equals the number of edges emanating from it. January 7,\n2020: DRAFT\n2: https://pypi.org/project/pyldpc/0.2/ January 7, 2020 DRAFT\n\nReferences:\n\n- C. E. Shannon, \"A mathematical theory of communication,\" Bell System Technical Journal, vol. 27, no. 34, pp. 379-423, Jul. 1948.- M. Luby, M. Mitzenmacher, A. Shokrollah, and D. Spielman, \"Analysis of low density codes and improved designs using irregular graphs,\" in Proc. of the Thirtieth Annual ACM Symposium on Theory of Computing, ser. STOC '98, New York, NY, USA, Jan. 1998, pp. 249-258.\n\n- J. Hagenauer, \"Rate-compatible punctured convolutional codes (rcpc codes) and their applications,\" IEEE Trans. on Communications, vol. 36, no. 4, pp. 389-400, Apr. 1988.\n\n- A. Shokrollahi, \"Raptor codes,\" IEEE Trans. on Information Theory, vol. 52, no. 6, pp. 2551-2567, Jun. 2006.\n\n- R. Gallager, \"Low-density parity-check codes,\" IRE Trans. on Information Theory, vol. 8, no. 1, pp. 21-28, Jan. 1962.\n\n- T. Richardson and S. Kudekar, \"Design of low-density parity check codes for 5g new radio,\" IEEE Communications Magazine, vol. 56, no. 3, pp. 28-34, Mar. 2018.\n\n- T. Richardson and R. Urbanke, Modern Coding Theory. New York, NY, USA: Cambridge University Press, 2008. January 7, 2020 DRAFT\n\n- T. J. Richardson, M. A. Shokrollahi, and R. L. Urbanke, \"Design of capacity-approaching irregular low-density parity-check codes,\" IEEE Trans. on Information Theory, vol. 47, no. 2, pp. 619-637, Feb 2001.\n\n- P. Elias, \"Error-free coding,\" Trans. of the IRE Professional Group on Information Theory, vol. 4, no. 4, pp. 29-37, Sep. 1954.\n\n- A. Shokrollahi and R. Storn, \"Design of efficient erasure codes with differential evolution,\" in Proc. of IEEE Int. Symp on Information Theory, ISIT'00, Sorrento, Italy, Jun. 2000.\n\n- R. Pascanu, T. Mikolov, and Y. Bengio, \"On the difficulty of training recurrent neural networks,\" in Proc. of the 30th Int. Conf. on Machine Learning, ICML'13, Atlanta, GA, USA, Jun. 2013.\n\n- Y. Bengio, P. Simard, and P. Frasconi, \"Learning long-term dependencies with gradient descent is difficult,\" IEEE Trans. on Neural Networks, vol. 5, no. 2, pp. 157-166, March 1994.\n\n- K. Doya, \"Bifurcations in the learning of recurrent neural networks,\" in Proc. of IEEE Int. Symp. on Circuits and Systems, ISCAS'92, Sapporo, Japan, May 1992, pp. 2777-2780.\n\n- L. K. Li, \"Learning fixed point patterns by recurrent networks,\" J. Comput. Syst. Sci., vol. 48, no. 2, pp. 203-213, Apr. 1994.\n\n- M. G. Luby, M. Mitzenmacher, M. A. Shokrollahi, D. A. Spielman, and V. Stemann, \"Practical loss-resilient codes,\" in Proc. of the ACM symposium on Theory of computing, STOC'97, El Paso, Texas, USA, May 1997, pp. 150-159.\n\n- S. Ruder, \"An overview of gradient descent optimization algorithms,\" CoRR, vol. abs/1609.04747, 2016. [Online]. Available: http://arxiv.org/abs/1609.04747\n\n- J. Ilonen, J.-K. Kamarainen, and J. Lampinen, \"Differential evolution training algorithm for feed-forward neural networks,\" Neural Processing Letters, vol. 17, no. 1, pp. 93-105, Feb 2003.\n\n- P. M\u00e1rquez-Neila, M. Salzmann, and P. Fua, \"Imposing hard constraints on deep networks: Promises and limitations,\" CoRR, vol. abs/1706.02025, 2017. [Online]. Available: http://arxiv.org/abs/1706.02025\n\n- T. Richardson and R. Urbanke, \"Fixed points and stability of density evolution,\" Commun. Inf. Syst., vol. 4, no. 1, pp. 103-116, 2004.\n\n- T. OShea and J. Hoydis, \"An introduction to deep learning for the physical layer,\" IEEE Trans. on Cognitive Communications and Networking, vol. 3, no. 4, pp. 563-575, Dec 2017.\n\n- E. Bourtsoulatze, D. Burth Kurka, and D. Gndz, \"Deep joint source-channel coding for wireless image transmission,\" IEEE Trans. on Cognitive Communications and Networking, vol. 5, no. 3, pp. 567-579, Sep. 2019.\n\n- T. Gruber, S. Cammerer, J. Hoydis, and S. t. Brink, \"On deep learning-based channel decoding,\" in Proc. of the 51st Annual Conference on Information Sciences and Systems, CISS'17, Baltimore, MD, USA, Mar. 2017.\n\n- E. Nachmani, E. Marciano, L. Lugosch, W. J. Gross, D. Burshtein, and Y. Beery, \"Deep learning methods for improved decoding of linear codes,\" IEEE Journal of Selected Topics in Signal Processing, vol. 12, no. 1, pp. 119-131, Feb 2018.\n\n- L. Huang, H. Zhang, R. Li, Y. Ge, and J. Wang, \"AI coding: Learning to construct error correction codes,\" CoRR, vol. abs/1901.05719, 2019. [Online]. Available: http://arxiv.org/abs/1901.05719\n\n- H. Dehghani, M. Ahmadi, S. Alikhani, and R. Hasni, \"Calculation of girth of tanner graph in LDPC codes,\" Trends in Applied Sciences Research, vol. 7, pp. 929-934, 11 2012.\n\n- T. J. Richardson and R. L. Urbanke, \"The capacity of low-density parity-check codes under message-passing decoding,\" IEEE Trans. on Information Theory, vol. 47, no. 2, pp. 599-618, Feb 2001.\n\n- I. Goodfellow, Y. Bengio, and A. Courville, Deep Learning. The MIT Press, 2016.\n\n- J. R. Kok and N. Vlassis, \" Collaborative Multiagent Reinforcement Learning by Payoff Propagation,\" J. Mach. Learn. Res., vol. 7, pp. 1789-1828, Dec. 2006.\n\n- M. G. Luby, M. Mitzenmacher, and M. A. Shokrollahi, \"Analysis of random processes via and-or tree evaluation,\" in Proc. of the Ninth Annual ACM-SIAM Symposium on Discrete Algorithms, ser. SODA '98, San Francisco, California, USA, Jun. 1998, pp. 364-373.\n\n- P. Oswald and A. Shokrollahi, \"Capacity-achieving sequences for the erasure channel,\" IEEE Trans. on Information Theory, vol. 48, no. 12, pp. 3017-3028, Dec 2002.\n\n- Y. Bengio, J. Louradour, R. Collobert, and J. Weston, \"Curriculum learning,\" in Proc. of the 26th Annual Int. Conf. on Machine Learning, ser. ICML '09, Montreal, Canada, Jun. 2009, pp. 41-48.\n\n- I. Goodfellow, Y. Bengio, and A. Courville, Deep Learning. MIT Press, 2016.\n\n- M. D. Zeiler, \"ADADELTA: an adaptive learning rate method,\" CoRR, vol. abs/1212.5701, 2012. [Online]. Available: http://arxiv.org/abs/1212.5701\n\n- P. Y. Simard, M. B. Ottaway, and D. H. Ballard, \"Fixed point analysis for recurrent networks,\" in Advances in Neural Information Processing Systems 1, D. S. Touretzky, Ed. Morgan-Kaufmann, 1989, pp. 149-159.\n\n- M. A. et al., \"TensorFlow: Large-scale machine learning on heterogeneous systems,\" 2015, software available from tensorflow.org. [Online]. Available: https://www.tensorflow.org/\n\n- D. P. Kingma and J. Ba, \"Adam: A method for stochastic optimization,\" 2014.\n\n- Y. Bengio, \"Practical recommendations for gradient-based training of deep architectures,\" CoRR, vol. abs/1206.5533, 2012. [Online]. Available: http://arxiv.org/abs/1206.5533\n\n", "annotations": {"ReferenceToTable": [{"begin": 38111, "end": 38114, "target": "#tab_2", "idx": 0}, {"begin": 38225, "end": 38228, "target": "#tab_2", "idx": 1}, {"begin": 38396, "end": 38399, "target": "#tab_2", "idx": 2}, {"begin": 38988, "end": 38991, "target": "#tab_2", "idx": 3}, {"begin": 48634, "end": 48637, "target": "#tab_2", "idx": 4}], "ReferenceToFootnote": [{"begin": 4872, "end": 4873, "target": "#foot_1", "idx": 0}, {"begin": 35702, "end": 35703, "target": "#foot_3", "idx": 1}], "SectionMain": [{"begin": 1892, "end": 53915, "idx": 0}], "ReferenceToFormula": [{"begin": 19202, "end": 19203, "target": "#formula_2", "idx": 0}, {"begin": 23094, "end": 23095, "target": "#formula_5", "idx": 1}, {"begin": 40255, "end": 40257, "target": "#formula_15", "idx": 2}, {"begin": 40929, "end": 40930, "target": "#formula_10", "idx": 3}], "SectionReference": [{"begin": 54106, "end": 60480, "idx": 0}], "SectionHeader": [{"begin": 0, "end": 1892, "idx": 0}], "Div": [{"begin": 105, "end": 1457, "idx": 0}, {"begin": 1458, "end": 1884, "idx": 1}, {"begin": 1895, "end": 11838, "idx": 2}, {"begin": 11840, "end": 18225, "idx": 3}, {"begin": 18227, "end": 18368, "idx": 4}, {"begin": 18370, "end": 19308, "idx": 5}, {"begin": 19310, "end": 20855, "idx": 6}, {"begin": 20857, "end": 22094, "idx": 7}, {"begin": 22096, "end": 22522, "idx": 8}, {"begin": 22524, "end": 24023, "idx": 9}, {"begin": 24025, "end": 24931, "idx": 10}, {"begin": 24933, "end": 31291, "idx": 11}, {"begin": 31293, "end": 37155, "idx": 12}, {"begin": 37157, "end": 37894, "idx": 13}, {"begin": 37896, "end": 39724, "idx": 14}, {"begin": 39726, "end": 44844, "idx": 15}, {"begin": 44846, "end": 46017, "idx": 16}, {"begin": 46019, "end": 48415, "idx": 17}, {"begin": 48417, "end": 50709, "idx": 18}, {"begin": 50711, "end": 52598, "idx": 19}, {"begin": 52600, "end": 53915, "idx": 20}], "Head": [{"begin": 1458, "end": 1473, "idx": 0}, {"begin": 11840, "end": 11856, "idx": 1}, {"begin": 18227, "end": 18242, "idx": 2}, {"begin": 18370, "end": 18391, "idx": 3}, {"begin": 19310, "end": 19343, "idx": 4}, {"begin": 20857, "end": 20877, "idx": 5}, {"begin": 22096, "end": 22124, "idx": 6}, {"begin": 22524, "end": 22547, "idx": 7}, {"begin": 24025, "end": 24057, "idx": 8}, {"begin": 24933, "end": 24960, "idx": 9}, {"begin": 31293, "end": 31316, "idx": 10}, {"begin": 37157, "end": 37173, "idx": 11}, {"begin": 37896, "end": 37927, "idx": 12}, {"begin": 39726, "end": 39755, "idx": 13}, {"begin": 44846, "end": 44889, "idx": 14}, {"begin": 46019, "end": 46045, "idx": 15}, {"begin": 48417, "end": 48430, "idx": 16}, {"begin": 50711, "end": 50739, "idx": 17}, {"begin": 52600, "end": 52633, "idx": 18}], "Paragraph": [{"begin": 105, "end": 914, "idx": 0}, {"begin": 915, "end": 1457, "idx": 1}, {"begin": 1474, "end": 1884, "idx": 2}, {"begin": 1895, "end": 1934, "idx": 3}, {"begin": 1970, "end": 2079, "idx": 4}, {"begin": 2080, "end": 2167, "idx": 5}, {"begin": 2168, "end": 2739, "idx": 6}, {"begin": 2740, "end": 3303, "idx": 7}, {"begin": 3304, "end": 3640, "idx": 8}, {"begin": 3641, "end": 3824, "idx": 9}, {"begin": 3825, "end": 3923, "idx": 10}, {"begin": 3924, "end": 5043, "idx": 11}, {"begin": 5044, "end": 6349, "idx": 12}, {"begin": 6350, "end": 7732, "idx": 13}, {"begin": 7733, "end": 8889, "idx": 14}, {"begin": 8890, "end": 9900, "idx": 15}, {"begin": 9901, "end": 10351, "idx": 16}, {"begin": 10352, "end": 10530, "idx": 17}, {"begin": 10531, "end": 10993, "idx": 18}, {"begin": 10994, "end": 11360, "idx": 19}, {"begin": 11361, "end": 11838, "idx": 20}, {"begin": 11857, "end": 13554, "idx": 21}, {"begin": 13555, "end": 14458, "idx": 22}, {"begin": 14459, "end": 14960, "idx": 23}, {"begin": 14961, "end": 17587, "idx": 24}, {"begin": 17588, "end": 17609, "idx": 25}, {"begin": 17610, "end": 17704, "idx": 26}, {"begin": 17705, "end": 18225, "idx": 27}, {"begin": 18243, "end": 18368, "idx": 28}, {"begin": 18392, "end": 18549, "idx": 29}, {"begin": 18586, "end": 18935, "idx": 30}, {"begin": 18968, "end": 19156, "idx": 31}, {"begin": 19157, "end": 19308, "idx": 32}, {"begin": 19344, "end": 19492, "idx": 33}, {"begin": 19544, "end": 19637, "idx": 34}, {"begin": 19638, "end": 20146, "idx": 35}, {"begin": 20147, "end": 20855, "idx": 36}, {"begin": 20878, "end": 21063, "idx": 37}, {"begin": 21064, "end": 21152, "idx": 38}, {"begin": 21184, "end": 21796, "idx": 39}, {"begin": 21797, "end": 22094, "idx": 40}, {"begin": 22125, "end": 22522, "idx": 41}, {"begin": 22548, "end": 22637, "idx": 42}, {"begin": 22674, "end": 22983, "idx": 43}, {"begin": 22984, "end": 23486, "idx": 44}, {"begin": 23510, "end": 23694, "idx": 45}, {"begin": 23695, "end": 24023, "idx": 46}, {"begin": 24058, "end": 24931, "idx": 47}, {"begin": 24961, "end": 25063, "idx": 48}, {"begin": 25064, "end": 25858, "idx": 49}, {"begin": 25947, "end": 26043, "idx": 50}, {"begin": 26044, "end": 26146, "idx": 51}, {"begin": 26223, "end": 26413, "idx": 52}, {"begin": 26461, "end": 27414, "idx": 53}, {"begin": 27538, "end": 28229, "idx": 54}, {"begin": 28381, "end": 28596, "idx": 55}, {"begin": 28632, "end": 28633, "idx": 56}, {"begin": 28673, "end": 28875, "idx": 57}, {"begin": 28876, "end": 28967, "idx": 58}, {"begin": 29049, "end": 29652, "idx": 59}, {"begin": 29653, "end": 29953, "idx": 60}, {"begin": 29954, "end": 30526, "idx": 61}, {"begin": 30527, "end": 31291, "idx": 62}, {"begin": 31317, "end": 31961, "idx": 63}, {"begin": 31962, "end": 32525, "idx": 64}, {"begin": 32526, "end": 32609, "idx": 65}, {"begin": 32647, "end": 32648, "idx": 66}, {"begin": 32649, "end": 32784, "idx": 67}, {"begin": 32785, "end": 32946, "idx": 68}, {"begin": 32947, "end": 33402, "idx": 69}, {"begin": 33454, "end": 33623, "idx": 70}, {"begin": 33624, "end": 34284, "idx": 71}, {"begin": 34285, "end": 34475, "idx": 72}, {"begin": 34476, "end": 35621, "idx": 73}, {"begin": 35622, "end": 36012, "idx": 74}, {"begin": 36013, "end": 36941, "idx": 75}, {"begin": 36942, "end": 37155, "idx": 76}, {"begin": 37174, "end": 37894, "idx": 77}, {"begin": 37928, "end": 38389, "idx": 78}, {"begin": 38390, "end": 38794, "idx": 79}, {"begin": 38795, "end": 38993, "idx": 80}, {"begin": 38994, "end": 39194, "idx": 81}, {"begin": 39195, "end": 39492, "idx": 82}, {"begin": 39493, "end": 39724, "idx": 83}, {"begin": 39756, "end": 41807, "idx": 84}, {"begin": 41808, "end": 42095, "idx": 85}, {"begin": 42096, "end": 43330, "idx": 86}, {"begin": 43331, "end": 44844, "idx": 87}, {"begin": 44890, "end": 46017, "idx": 88}, {"begin": 46046, "end": 46326, "idx": 89}, {"begin": 46327, "end": 46417, "idx": 90}, {"begin": 46418, "end": 48415, "idx": 91}, {"begin": 48431, "end": 49166, "idx": 92}, {"begin": 49253, "end": 50709, "idx": 93}, {"begin": 50740, "end": 52028, "idx": 94}, {"begin": 52029, "end": 52598, "idx": 95}, {"begin": 52634, "end": 53915, "idx": 96}], "ReferenceToBib": [{"begin": 2318, "end": 2321, "target": "#b4", "idx": 0}, {"begin": 2534, "end": 2537, "target": "#b5", "idx": 1}, {"begin": 2848, "end": 2851, "target": "#b0", "idx": 2}, {"begin": 3406, "end": 3409, "target": "#b6", "idx": 3}, {"begin": 3672, "end": 3675, "target": "#b4", "idx": 4}, {"begin": 5242, "end": 5245, "target": "#b7", "idx": 5}, {"begin": 5543, "end": 5546, "target": "#b8", "idx": 6}, {"begin": 5611, "end": 5614, "target": "#b7", "idx": 7}, {"begin": 5616, "end": 5620, "target": "#b9", "idx": 8}, {"begin": 6202, "end": 6205, "target": "#b7", "idx": 9}, {"begin": 6651, "end": 6655, "target": "#b10", "idx": 10}, {"begin": 6658, "end": 6662, "target": "#b12", "idx": 11}, {"begin": 6846, "end": 6850, "target": "#b13", "idx": 12}, {"begin": 7461, "end": 7465, "target": "#b14", "idx": 13}, {"begin": 7848, "end": 7852, "target": "#b15", "idx": 14}, {"begin": 7901, "end": 7904, "target": "#b7", "idx": 15}, {"begin": 8255, "end": 8259, "target": "#b16", "idx": 16}, {"begin": 8449, "end": 8452, "target": "#b7", "idx": 17}, {"begin": 9487, "end": 9490, "target": "#b7", "idx": 18}, {"begin": 9720, "end": 9724, "target": "#b17", "idx": 19}, {"begin": 10347, "end": 10350, "target": "#b7", "idx": 20}, {"begin": 10898, "end": 10902, "target": "#b10", "idx": 21}, {"begin": 10904, "end": 10908, "target": "#b12", "idx": 22}, {"begin": 10989, "end": 10992, "target": "#b6", "idx": 23}, {"begin": 11356, "end": 11359, "target": "#b7", "idx": 24}, {"begin": 11878, "end": 11882, "target": "#b14", "idx": 25}, {"begin": 12071, "end": 12074, "target": "#b7", "idx": 26}, {"begin": 13009, "end": 13012, "target": "#b7", "idx": 27}, {"begin": 13129, "end": 13132, "target": "#b7", "idx": 28}, {"begin": 13444, "end": 13448, "target": "#b16", "idx": 29}, {"begin": 13697, "end": 13700, "target": "#b7", "idx": 30}, {"begin": 13702, "end": 13706, "target": "#b18", "idx": 31}, {"begin": 14072, "end": 14075, "target": "#b6", "idx": 32}, {"begin": 14453, "end": 14457, "target": "#b18", "idx": 33}, {"begin": 14634, "end": 14638, "target": "#b11", "idx": 34}, {"begin": 14860, "end": 14864, "target": "#b12", "idx": 35}, {"begin": 15224, "end": 15228, "target": "#b19", "idx": 36}, {"begin": 15374, "end": 15378, "target": "#b20", "idx": 37}, {"begin": 15652, "end": 15656, "target": "#b21", "idx": 38}, {"begin": 16321, "end": 16325, "target": "#b22", "idx": 39}, {"begin": 16757, "end": 16761, "target": "#b22", "idx": 40}, {"begin": 17025, "end": 17029, "target": "#b22", "idx": 41}, {"begin": 17056, "end": 17060, "target": "#b23", "idx": 42}, {"begin": 17859, "end": 17862, "target": "#b5", "idx": 43}, {"begin": 18220, "end": 18224, "target": "#b14", "idx": 44}, {"begin": 20507, "end": 20511, "target": "#b14", "idx": 45}, {"begin": 20750, "end": 20754, "target": "#b24", "idx": 46}, {"begin": 20850, "end": 20854, "target": "#b25", "idx": 47}, {"begin": 23149, "end": 23152, "target": "#b2", "idx": 48}, {"begin": 23689, "end": 23693, "target": "#b26", "idx": 49}, {"begin": 24158, "end": 24161, "target": "#b1", "idx": 50}, {"begin": 24926, "end": 24930, "target": "#b27", "idx": 51}, {"begin": 25794, "end": 25798, "target": "#b28", "idx": 52}, {"begin": 26038, "end": 26041, "target": "#b6", "idx": 53}, {"begin": 26090, "end": 26093, "target": "#b6", "idx": 54}, {"begin": 26384, "end": 26388, "target": "#b29", "idx": 55}, {"begin": 27296, "end": 27300, "target": "#b30", "idx": 56}, {"begin": 27892, "end": 27896, "target": "#b31", "idx": 57}, {"begin": 29332, "end": 29336, "target": "#b9", "idx": 58}, {"begin": 29454, "end": 29458, "target": "#b32", "idx": 59}, {"begin": 29908, "end": 29911, "target": "#b6", "idx": 60}, {"begin": 30521, "end": 30525, "target": "#b33", "idx": 61}, {"begin": 30980, "end": 30983, "target": "#b7", "idx": 62}, {"begin": 31694, "end": 31698, "target": "#b29", "idx": 63}, {"begin": 32566, "end": 32569, "target": "#b7", "idx": 64}, {"begin": 33273, "end": 33277, "target": "#b9", "idx": 65}, {"begin": 34628, "end": 34631, "target": "#b7", "idx": 66}, {"begin": 34881, "end": 34885, "target": "#b15", "idx": 67}, {"begin": 36158, "end": 36162, "target": "#b11", "idx": 68}, {"begin": 37788, "end": 37792, "target": "#b34", "idx": 69}, {"begin": 38040, "end": 38043, "target": "#b6", "idx": 70}, {"begin": 38058, "end": 38061, "target": "#b1", "idx": 71}, {"begin": 39327, "end": 39330, "target": "#b6", "idx": 72}, {"begin": 42292, "end": 42296, "target": "#b15", "idx": 73}, {"begin": 43023, "end": 43027, "target": "#b35", "idx": 74}, {"begin": 43904, "end": 43908, "target": "#b36", "idx": 75}, {"begin": 47139, "end": 47142, "target": "#b7", "idx": 76}, {"begin": 48685, "end": 48688, "target": "#b7", "idx": 77}, {"begin": 51041, "end": 51044, "target": "#b6", "idx": 78}, {"begin": 51668, "end": 51671, "target": "#b7", "idx": 79}], "ReferenceString": [{"begin": 54121, "end": 54249, "id": "b0", "idx": 0}, {"begin": 54251, "end": 54514, "id": "b1", "idx": 1}, {"begin": 54518, "end": 54687, "id": "b2", "idx": 2}, {"begin": 54691, "end": 54799, "id": "b3", "idx": 3}, {"begin": 54803, "end": 54920, "id": "b4", "idx": 4}, {"begin": 54924, "end": 55082, "id": "b5", "idx": 5}, {"begin": 55086, "end": 55212, "id": "b6", "idx": 6}, {"begin": 55216, "end": 55420, "id": "b7", "idx": 7}, {"begin": 55424, "end": 55551, "id": "b8", "idx": 8}, {"begin": 55555, "end": 55735, "id": "b9", "idx": 9}, {"begin": 55739, "end": 55927, "id": "b10", "idx": 10}, {"begin": 55931, "end": 56111, "id": "b11", "idx": 11}, {"begin": 56115, "end": 56288, "id": "b12", "idx": 12}, {"begin": 56292, "end": 56419, "id": "b13", "idx": 13}, {"begin": 56423, "end": 56643, "id": "b14", "idx": 14}, {"begin": 56647, "end": 56801, "id": "b15", "idx": 15}, {"begin": 56805, "end": 56993, "id": "b16", "idx": 16}, {"begin": 56997, "end": 57197, "id": "b17", "idx": 17}, {"begin": 57201, "end": 57335, "id": "b18", "idx": 18}, {"begin": 57339, "end": 57515, "id": "b19", "idx": 19}, {"begin": 57519, "end": 57728, "id": "b20", "idx": 20}, {"begin": 57732, "end": 57942, "id": "b21", "idx": 21}, {"begin": 57946, "end": 58180, "id": "b22", "idx": 22}, {"begin": 58184, "end": 58375, "id": "b23", "idx": 23}, {"begin": 58379, "end": 58550, "id": "b24", "idx": 24}, {"begin": 58554, "end": 58744, "id": "b25", "idx": 25}, {"begin": 58748, "end": 58827, "id": "b26", "idx": 26}, {"begin": 58831, "end": 58986, "id": "b27", "idx": 27}, {"begin": 58990, "end": 59243, "id": "b28", "idx": 28}, {"begin": 59247, "end": 59409, "id": "b29", "idx": 29}, {"begin": 59413, "end": 59604, "id": "b30", "idx": 30}, {"begin": 59608, "end": 59683, "id": "b31", "idx": 31}, {"begin": 59687, "end": 59830, "id": "b32", "idx": 32}, {"begin": 59834, "end": 60041, "id": "b33", "idx": 33}, {"begin": 60045, "end": 60222, "id": "b34", "idx": 34}, {"begin": 60226, "end": 60301, "id": "b35", "idx": 35}, {"begin": 60305, "end": 60478, "id": "b36", "idx": 36}], "Sentence": [{"begin": 105, "end": 314, "idx": 0}, {"begin": 315, "end": 457, "idx": 1}, {"begin": 458, "end": 752, "idx": 2}, {"begin": 753, "end": 914, "idx": 3}, {"begin": 915, "end": 1003, "idx": 4}, {"begin": 1004, "end": 1149, "idx": 5}, {"begin": 1150, "end": 1274, "idx": 6}, {"begin": 1275, "end": 1457, "idx": 7}, {"begin": 1474, "end": 1568, "idx": 8}, {"begin": 1569, "end": 1777, "idx": 9}, {"begin": 1778, "end": 1884, "idx": 10}, {"begin": 1895, "end": 1934, "idx": 11}, {"begin": 1970, "end": 2079, "idx": 12}, {"begin": 2080, "end": 2086, "idx": 13}, {"begin": 2087, "end": 2167, "idx": 14}, {"begin": 2168, "end": 2279, "idx": 15}, {"begin": 2280, "end": 2538, "idx": 16}, {"begin": 2539, "end": 2739, "idx": 17}, {"begin": 2740, "end": 2852, "idx": 18}, {"begin": 2853, "end": 3061, "idx": 19}, {"begin": 3062, "end": 3161, "idx": 20}, {"begin": 3162, "end": 3303, "idx": 21}, {"begin": 3304, "end": 3410, "idx": 22}, {"begin": 3411, "end": 3578, "idx": 23}, {"begin": 3579, "end": 3640, "idx": 24}, {"begin": 3641, "end": 3824, "idx": 25}, {"begin": 3825, "end": 3923, "idx": 26}, {"begin": 3924, "end": 3952, "idx": 27}, {"begin": 3953, "end": 4332, "idx": 28}, {"begin": 4333, "end": 4733, "idx": 29}, {"begin": 4734, "end": 4919, "idx": 30}, {"begin": 4920, "end": 5043, "idx": 31}, {"begin": 5044, "end": 5246, "idx": 32}, {"begin": 5247, "end": 5434, "idx": 33}, {"begin": 5435, "end": 5621, "idx": 34}, {"begin": 5622, "end": 5913, "idx": 35}, {"begin": 5914, "end": 6206, "idx": 36}, {"begin": 6207, "end": 6349, "idx": 37}, {"begin": 6350, "end": 6492, "idx": 38}, {"begin": 6493, "end": 6663, "idx": 39}, {"begin": 6664, "end": 6851, "idx": 40}, {"begin": 6852, "end": 7055, "idx": 41}, {"begin": 7056, "end": 7280, "idx": 42}, {"begin": 7281, "end": 7389, "idx": 43}, {"begin": 7390, "end": 7584, "idx": 44}, {"begin": 7585, "end": 7732, "idx": 45}, {"begin": 7733, "end": 7853, "idx": 46}, {"begin": 7854, "end": 8119, "idx": 47}, {"begin": 8120, "end": 8260, "idx": 48}, {"begin": 8261, "end": 8426, "idx": 49}, {"begin": 8427, "end": 8556, "idx": 50}, {"begin": 8557, "end": 8665, "idx": 51}, {"begin": 8666, "end": 8889, "idx": 52}, {"begin": 8890, "end": 9008, "idx": 53}, {"begin": 9009, "end": 9295, "idx": 54}, {"begin": 9296, "end": 9515, "idx": 55}, {"begin": 9516, "end": 9725, "idx": 56}, {"begin": 9726, "end": 9900, "idx": 57}, {"begin": 9901, "end": 10012, "idx": 58}, {"begin": 10013, "end": 10202, "idx": 59}, {"begin": 10203, "end": 10351, "idx": 60}, {"begin": 10352, "end": 10530, "idx": 61}, {"begin": 10531, "end": 10698, "idx": 62}, {"begin": 10699, "end": 10993, "idx": 63}, {"begin": 10994, "end": 11235, "idx": 64}, {"begin": 11236, "end": 11360, "idx": 65}, {"begin": 11361, "end": 11432, "idx": 66}, {"begin": 11433, "end": 11492, "idx": 67}, {"begin": 11493, "end": 11668, "idx": 68}, {"begin": 11669, "end": 11838, "idx": 69}, {"begin": 11857, "end": 12067, "idx": 70}, {"begin": 12068, "end": 12132, "idx": 71}, {"begin": 12133, "end": 12318, "idx": 72}, {"begin": 12319, "end": 12457, "idx": 73}, {"begin": 12458, "end": 12601, "idx": 74}, {"begin": 12602, "end": 12807, "idx": 75}, {"begin": 12808, "end": 12962, "idx": 76}, {"begin": 12963, "end": 13116, "idx": 77}, {"begin": 13117, "end": 13345, "idx": 78}, {"begin": 13346, "end": 13554, "idx": 79}, {"begin": 13555, "end": 13707, "idx": 80}, {"begin": 13708, "end": 13904, "idx": 81}, {"begin": 13905, "end": 14068, "idx": 82}, {"begin": 14069, "end": 14265, "idx": 83}, {"begin": 14266, "end": 14458, "idx": 84}, {"begin": 14459, "end": 14630, "idx": 85}, {"begin": 14631, "end": 14856, "idx": 86}, {"begin": 14857, "end": 14960, "idx": 87}, {"begin": 14961, "end": 15081, "idx": 88}, {"begin": 15082, "end": 15220, "idx": 89}, {"begin": 15221, "end": 15370, "idx": 90}, {"begin": 15371, "end": 15648, "idx": 91}, {"begin": 15649, "end": 15835, "idx": 92}, {"begin": 15836, "end": 15982, "idx": 93}, {"begin": 15983, "end": 16317, "idx": 94}, {"begin": 16318, "end": 16426, "idx": 95}, {"begin": 16427, "end": 16713, "idx": 96}, {"begin": 16714, "end": 16854, "idx": 97}, {"begin": 16855, "end": 16943, "idx": 98}, {"begin": 16944, "end": 17052, "idx": 99}, {"begin": 17053, "end": 17225, "idx": 100}, {"begin": 17226, "end": 17451, "idx": 101}, {"begin": 17452, "end": 17587, "idx": 102}, {"begin": 17588, "end": 17609, "idx": 103}, {"begin": 17610, "end": 17704, "idx": 104}, {"begin": 17705, "end": 17863, "idx": 105}, {"begin": 17864, "end": 18006, "idx": 106}, {"begin": 18007, "end": 18225, "idx": 107}, {"begin": 18243, "end": 18368, "idx": 108}, {"begin": 18392, "end": 18474, "idx": 109}, {"begin": 18475, "end": 18549, "idx": 110}, {"begin": 18586, "end": 18642, "idx": 111}, {"begin": 18643, "end": 18793, "idx": 112}, {"begin": 18794, "end": 18935, "idx": 113}, {"begin": 18968, "end": 19156, "idx": 114}, {"begin": 19157, "end": 19199, "idx": 115}, {"begin": 19200, "end": 19308, "idx": 116}, {"begin": 19344, "end": 19492, "idx": 117}, {"begin": 19544, "end": 19637, "idx": 118}, {"begin": 19638, "end": 19643, "idx": 119}, {"begin": 19644, "end": 19763, "idx": 120}, {"begin": 19764, "end": 19834, "idx": 121}, {"begin": 19835, "end": 19976, "idx": 122}, {"begin": 19977, "end": 20146, "idx": 123}, {"begin": 20147, "end": 20250, "idx": 124}, {"begin": 20251, "end": 20366, "idx": 125}, {"begin": 20367, "end": 20512, "idx": 126}, {"begin": 20513, "end": 20718, "idx": 127}, {"begin": 20719, "end": 20855, "idx": 128}, {"begin": 20878, "end": 20963, "idx": 129}, {"begin": 20964, "end": 21063, "idx": 130}, {"begin": 21064, "end": 21152, "idx": 131}, {"begin": 21184, "end": 21244, "idx": 132}, {"begin": 21245, "end": 21403, "idx": 133}, {"begin": 21404, "end": 21577, "idx": 134}, {"begin": 21578, "end": 21639, "idx": 135}, {"begin": 21640, "end": 21796, "idx": 136}, {"begin": 21797, "end": 21945, "idx": 137}, {"begin": 21946, "end": 22094, "idx": 138}, {"begin": 22125, "end": 22223, "idx": 139}, {"begin": 22224, "end": 22301, "idx": 140}, {"begin": 22302, "end": 22393, "idx": 141}, {"begin": 22394, "end": 22522, "idx": 142}, {"begin": 22548, "end": 22637, "idx": 143}, {"begin": 22674, "end": 22830, "idx": 144}, {"begin": 22831, "end": 22934, "idx": 145}, {"begin": 22935, "end": 22983, "idx": 146}, {"begin": 22984, "end": 23153, "idx": 147}, {"begin": 23154, "end": 23346, "idx": 148}, {"begin": 23347, "end": 23441, "idx": 149}, {"begin": 23442, "end": 23486, "idx": 150}, {"begin": 23510, "end": 23694, "idx": 151}, {"begin": 23695, "end": 24023, "idx": 152}, {"begin": 24058, "end": 24162, "idx": 153}, {"begin": 24163, "end": 24374, "idx": 154}, {"begin": 24375, "end": 24586, "idx": 155}, {"begin": 24587, "end": 24694, "idx": 156}, {"begin": 24695, "end": 24931, "idx": 157}, {"begin": 24961, "end": 25063, "idx": 158}, {"begin": 25064, "end": 25167, "idx": 159}, {"begin": 25168, "end": 25304, "idx": 160}, {"begin": 25305, "end": 25612, "idx": 161}, {"begin": 25613, "end": 25711, "idx": 162}, {"begin": 25712, "end": 25858, "idx": 163}, {"begin": 25947, "end": 26043, "idx": 164}, {"begin": 26044, "end": 26095, "idx": 165}, {"begin": 26096, "end": 26146, "idx": 166}, {"begin": 26223, "end": 26352, "idx": 167}, {"begin": 26353, "end": 26413, "idx": 168}, {"begin": 26461, "end": 26701, "idx": 169}, {"begin": 26702, "end": 26782, "idx": 170}, {"begin": 26783, "end": 26955, "idx": 171}, {"begin": 26956, "end": 27084, "idx": 172}, {"begin": 27085, "end": 27301, "idx": 173}, {"begin": 27302, "end": 27414, "idx": 174}, {"begin": 27538, "end": 27683, "idx": 175}, {"begin": 27684, "end": 27897, "idx": 176}, {"begin": 27898, "end": 28029, "idx": 177}, {"begin": 28030, "end": 28229, "idx": 178}, {"begin": 28381, "end": 28596, "idx": 179}, {"begin": 28632, "end": 28633, "idx": 180}, {"begin": 28673, "end": 28729, "idx": 181}, {"begin": 28730, "end": 28875, "idx": 182}, {"begin": 28876, "end": 28967, "idx": 183}, {"begin": 29049, "end": 29281, "idx": 184}, {"begin": 29282, "end": 29371, "idx": 185}, {"begin": 29372, "end": 29652, "idx": 186}, {"begin": 29653, "end": 29753, "idx": 187}, {"begin": 29754, "end": 29953, "idx": 188}, {"begin": 29954, "end": 30235, "idx": 189}, {"begin": 30236, "end": 30330, "idx": 190}, {"begin": 30331, "end": 30526, "idx": 191}, {"begin": 30527, "end": 30591, "idx": 192}, {"begin": 30592, "end": 30709, "idx": 193}, {"begin": 30710, "end": 30861, "idx": 194}, {"begin": 30862, "end": 31142, "idx": 195}, {"begin": 31143, "end": 31291, "idx": 196}, {"begin": 31317, "end": 31518, "idx": 197}, {"begin": 31519, "end": 31699, "idx": 198}, {"begin": 31700, "end": 31961, "idx": 199}, {"begin": 31962, "end": 32179, "idx": 200}, {"begin": 32180, "end": 32257, "idx": 201}, {"begin": 32258, "end": 32362, "idx": 202}, {"begin": 32363, "end": 32525, "idx": 203}, {"begin": 32526, "end": 32609, "idx": 204}, {"begin": 32647, "end": 32648, "idx": 205}, {"begin": 32649, "end": 32784, "idx": 206}, {"begin": 32785, "end": 32946, "idx": 207}, {"begin": 32947, "end": 33192, "idx": 208}, {"begin": 33193, "end": 33402, "idx": 209}, {"begin": 33454, "end": 33623, "idx": 210}, {"begin": 33624, "end": 33804, "idx": 211}, {"begin": 33805, "end": 34035, "idx": 212}, {"begin": 34036, "end": 34284, "idx": 213}, {"begin": 34285, "end": 34414, "idx": 214}, {"begin": 34415, "end": 34475, "idx": 215}, {"begin": 34476, "end": 34632, "idx": 216}, {"begin": 34633, "end": 34886, "idx": 217}, {"begin": 34887, "end": 35164, "idx": 218}, {"begin": 35165, "end": 35391, "idx": 219}, {"begin": 35392, "end": 35621, "idx": 220}, {"begin": 35622, "end": 35851, "idx": 221}, {"begin": 35852, "end": 36012, "idx": 222}, {"begin": 36013, "end": 36132, "idx": 223}, {"begin": 36133, "end": 36351, "idx": 224}, {"begin": 36352, "end": 36498, "idx": 225}, {"begin": 36499, "end": 36609, "idx": 226}, {"begin": 36610, "end": 36733, "idx": 227}, {"begin": 36734, "end": 36941, "idx": 228}, {"begin": 36942, "end": 37155, "idx": 229}, {"begin": 37174, "end": 37432, "idx": 230}, {"begin": 37433, "end": 37482, "idx": 231}, {"begin": 37483, "end": 37574, "idx": 232}, {"begin": 37575, "end": 37763, "idx": 233}, {"begin": 37764, "end": 37894, "idx": 234}, {"begin": 37928, "end": 38171, "idx": 235}, {"begin": 38172, "end": 38179, "idx": 236}, {"begin": 38180, "end": 38310, "idx": 237}, {"begin": 38311, "end": 38389, "idx": 238}, {"begin": 38390, "end": 38525, "idx": 239}, {"begin": 38526, "end": 38794, "idx": 240}, {"begin": 38795, "end": 38993, "idx": 241}, {"begin": 38994, "end": 39007, "idx": 242}, {"begin": 39008, "end": 39194, "idx": 243}, {"begin": 39195, "end": 39307, "idx": 244}, {"begin": 39308, "end": 39414, "idx": 245}, {"begin": 39415, "end": 39492, "idx": 246}, {"begin": 39493, "end": 39526, "idx": 247}, {"begin": 39527, "end": 39724, "idx": 248}, {"begin": 39756, "end": 40002, "idx": 249}, {"begin": 40003, "end": 40155, "idx": 250}, {"begin": 40156, "end": 40341, "idx": 251}, {"begin": 40342, "end": 40427, "idx": 252}, {"begin": 40428, "end": 40621, "idx": 253}, {"begin": 40622, "end": 40688, "idx": 254}, {"begin": 40689, "end": 40991, "idx": 255}, {"begin": 40992, "end": 41224, "idx": 256}, {"begin": 41225, "end": 41313, "idx": 257}, {"begin": 41314, "end": 41483, "idx": 258}, {"begin": 41484, "end": 41592, "idx": 259}, {"begin": 41593, "end": 41698, "idx": 260}, {"begin": 41699, "end": 41807, "idx": 261}, {"begin": 41808, "end": 41947, "idx": 262}, {"begin": 41948, "end": 42095, "idx": 263}, {"begin": 42096, "end": 42169, "idx": 264}, {"begin": 42170, "end": 42350, "idx": 265}, {"begin": 42351, "end": 42488, "idx": 266}, {"begin": 42489, "end": 42618, "idx": 267}, {"begin": 42619, "end": 42684, "idx": 268}, {"begin": 42685, "end": 42838, "idx": 269}, {"begin": 42839, "end": 42925, "idx": 270}, {"begin": 42926, "end": 43028, "idx": 271}, {"begin": 43029, "end": 43214, "idx": 272}, {"begin": 43215, "end": 43330, "idx": 273}, {"begin": 43331, "end": 43607, "idx": 274}, {"begin": 43608, "end": 43909, "idx": 275}, {"begin": 43910, "end": 43986, "idx": 276}, {"begin": 43987, "end": 44155, "idx": 277}, {"begin": 44156, "end": 44244, "idx": 278}, {"begin": 44245, "end": 44401, "idx": 279}, {"begin": 44402, "end": 44479, "idx": 280}, {"begin": 44480, "end": 44751, "idx": 281}, {"begin": 44752, "end": 44844, "idx": 282}, {"begin": 44890, "end": 45028, "idx": 283}, {"begin": 45029, "end": 45145, "idx": 284}, {"begin": 45146, "end": 45409, "idx": 285}, {"begin": 45410, "end": 45525, "idx": 286}, {"begin": 45526, "end": 45921, "idx": 287}, {"begin": 45922, "end": 46017, "idx": 288}, {"begin": 46046, "end": 46326, "idx": 289}, {"begin": 46327, "end": 46417, "idx": 290}, {"begin": 46418, "end": 46504, "idx": 291}, {"begin": 46505, "end": 46656, "idx": 292}, {"begin": 46657, "end": 46820, "idx": 293}, {"begin": 46821, "end": 46948, "idx": 294}, {"begin": 46949, "end": 47102, "idx": 295}, {"begin": 47103, "end": 47234, "idx": 296}, {"begin": 47235, "end": 47413, "idx": 297}, {"begin": 47414, "end": 47601, "idx": 298}, {"begin": 47602, "end": 47809, "idx": 299}, {"begin": 47810, "end": 47959, "idx": 300}, {"begin": 47960, "end": 48114, "idx": 301}, {"begin": 48115, "end": 48231, "idx": 302}, {"begin": 48232, "end": 48330, "idx": 303}, {"begin": 48331, "end": 48415, "idx": 304}, {"begin": 48431, "end": 48638, "idx": 305}, {"begin": 48639, "end": 48746, "idx": 306}, {"begin": 48747, "end": 48909, "idx": 307}, {"begin": 48910, "end": 49130, "idx": 308}, {"begin": 49131, "end": 49166, "idx": 309}, {"begin": 49253, "end": 49401, "idx": 310}, {"begin": 49402, "end": 49545, "idx": 311}, {"begin": 49546, "end": 49676, "idx": 312}, {"begin": 49677, "end": 49800, "idx": 313}, {"begin": 49801, "end": 49895, "idx": 314}, {"begin": 49896, "end": 50021, "idx": 315}, {"begin": 50022, "end": 50148, "idx": 316}, {"begin": 50149, "end": 50431, "idx": 317}, {"begin": 50432, "end": 50614, "idx": 318}, {"begin": 50615, "end": 50709, "idx": 319}, {"begin": 50740, "end": 50940, "idx": 320}, {"begin": 50941, "end": 51020, "idx": 321}, {"begin": 51021, "end": 51161, "idx": 322}, {"begin": 51162, "end": 51306, "idx": 323}, {"begin": 51307, "end": 51458, "idx": 324}, {"begin": 51459, "end": 51562, "idx": 325}, {"begin": 51563, "end": 51734, "idx": 326}, {"begin": 51735, "end": 51905, "idx": 327}, {"begin": 51906, "end": 51943, "idx": 328}, {"begin": 51944, "end": 52028, "idx": 329}, {"begin": 52029, "end": 52171, "idx": 330}, {"begin": 52172, "end": 52241, "idx": 331}, {"begin": 52242, "end": 52362, "idx": 332}, {"begin": 52363, "end": 52598, "idx": 333}, {"begin": 52634, "end": 52835, "idx": 334}, {"begin": 52836, "end": 53051, "idx": 335}, {"begin": 53052, "end": 53168, "idx": 336}, {"begin": 53169, "end": 53323, "idx": 337}, {"begin": 53324, "end": 53490, "idx": 338}, {"begin": 53491, "end": 53713, "idx": 339}, {"begin": 53714, "end": 53915, "idx": 340}], "ReferenceToFigure": [{"begin": 1975, "end": 1976, "idx": 0}, {"begin": 3638, "end": 3639, "target": "#fig_0", "idx": 1}, {"begin": 4219, "end": 4220, "idx": 2}, {"begin": 4366, "end": 4367, "idx": 3}, {"begin": 5993, "end": 5994, "idx": 4}, {"begin": 18472, "end": 18473, "target": "#fig_0", "idx": 5}, {"begin": 19407, "end": 19414, "idx": 6}, {"begin": 19704, "end": 19705, "idx": 7}, {"begin": 21805, "end": 21806, "idx": 8}, {"begin": 22981, "end": 22982, "idx": 9}, {"begin": 24426, "end": 24427, "target": "#fig_3", "idx": 10}, {"begin": 25672, "end": 25674, "target": "#fig_0", "idx": 11}, {"begin": 39550, "end": 39551, "target": "#fig_5", "idx": 12}, {"begin": 40011, "end": 40013, "target": "#fig_6", "idx": 13}, {"begin": 40738, "end": 40740, "target": "#fig_6", "idx": 14}, {"begin": 41104, "end": 41106, "target": "#fig_6", "idx": 15}, {"begin": 42166, "end": 42168, "target": "#fig_6", "idx": 16}, {"begin": 42627, "end": 42629, "target": "#fig_6", "idx": 17}, {"begin": 44161, "end": 44163, "target": "#fig_7", "idx": 18}, {"begin": 45049, "end": 45051, "target": "#fig_0", "idx": 19}, {"begin": 45431, "end": 45433, "target": "#fig_0", "idx": 20}, {"begin": 45970, "end": 45972, "target": "#fig_0", "idx": 21}, {"begin": 46426, "end": 46428, "target": "#fig_0", "idx": 22}, {"begin": 47610, "end": 47612, "target": "#fig_0", "idx": 23}, {"begin": 49261, "end": 49263, "target": "#fig_0", "idx": 24}, {"begin": 49971, "end": 49973, "target": "#fig_6", "idx": 25}, {"begin": 50196, "end": 50198, "target": "#fig_0", "idx": 26}, {"begin": 50637, "end": 50639, "target": "#fig_0", "idx": 27}, {"begin": 52037, "end": 52039, "target": "#fig_3", "idx": 28}, {"begin": 52250, "end": 52252, "target": "#fig_0", "idx": 29}], "Abstract": [{"begin": 95, "end": 1884, "idx": 0}], "SectionFootnote": [{"begin": 53917, "end": 54104, "idx": 0}], "Footnote": [{"begin": 53928, "end": 53949, "id": "foot_0", "idx": 0}, {"begin": 53950, "end": 54030, "id": "foot_1", "n": "1", "idx": 1}, {"begin": 54031, "end": 54042, "id": "foot_2", "n": "2020", "idx": 2}, {"begin": 54043, "end": 54104, "id": "foot_3", "n": "2", "idx": 3}]}}